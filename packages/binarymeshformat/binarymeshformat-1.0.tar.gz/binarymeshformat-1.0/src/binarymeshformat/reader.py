#!/usr/bin/env python3

import struct

from .meshdata import Track, Mesh

class MeshReader:
    """
        Class for reading meshes from a collection of bytes. This class
        could be considered private. It is used by the function
        'loadMeshTracks.
        
        The readXyz methods are intented to read the corresponding 
        java DataOutputStream written values.
    """
    def __init__(self, data):
        """
            Starts a reader over the provided bytes.
            Args:
                data: bytes-like object with mesh tracks. Will be used 
                      with struct.unpack_from.
        """
        self.bytes = data
        self.pos = 0
        self.tracks = []
    def load(self):
        """
            Populates and the list of tracks for this reader. 
        """
        self.version = self.readInt()
        self.track_count = self.readInt()
        for i in range(self.track_count):
            name = self.readUTFString();
            track = Track(name)
            mesh_count = self.readInt()
            for j in range(mesh_count):
                frame = self.readInt()
                position_count = self.readInt()
                positions = self.readDoubles(position_count)
                connection_count = self.readInt()
                connections = self.readInts(connection_count)
                triangle_count = self.readInt()
                triangles = self.readInts(triangle_count)
                track.addMesh(frame, Mesh(positions, connections, triangles))
            self.tracks.append(track)
            
                
    def readInt(self):
        """
            Reads a single 4 byte int big endian.
        """
        i = struct.unpack_from(">i", self.bytes, self.pos)[0]
        self.pos += 4
        return i
    
    def readInts(self, n):
        """
            Reads n 4 byte big-endian ints.
        """
        ints = struct.unpack_from(">%si"%n, self.bytes, self.pos)
        self.pos += 4*n
        return ints
        
    def readDouble(self):
        """
            Resuts a single 8 byte floating point value, big endian.
        """
        d = struct.unpack_from(">d", self.bytes, self.pos)[0]
        self.pos+=8
        return d
    
    def readDoubles(self, n):
        """
            Reads n 8 byte floating point values, big endian.
            Args:
                n: number of floats to read.
        """
        doubles = struct.unpack_from(">%sd"%n, self.bytes, self.pos)
        self.pos += n*8
        return doubles
        
    def readUTFString(self):
        """
            Reads a utf string, the first 2 bytes are a big endian
            short that represents the number of characters. Then it 
            reads that many bytes/characters.
        """
        s = struct.unpack_from(">h", self.bytes, self.pos)[0]
        self.pos += 2
        name = struct.unpack_from("%ss"%s, self.bytes, self.pos)[0]
        self.pos += s
        return name.decode("utf-8")
    def getTracks(self):
        """
            returns the generated tracks, should be called after load.
        """
        return self.tracks

def loadMeshTracks(filename):
    """
      For opening mesh files generated by our Deformable Mesh plugin.
      Args:
        filename: a str to be used with open.
    """
    with open(filename, 'rb') as f:
        data = f.read()
        reader = MeshReader(data)
        reader.load()
        return reader.tracks
    return None

    

if __name__=="__main__":
    import sys
    print("testing purposes only")
    tracks = loadMeshTracks(sys.argv[1])
    print("%d tracks loaded"%len(tracks))
    for track in tracks:
        print("%s:"%track.name)
        meshes = track.meshes
        for mesh in meshes:
            print("\tframe: %s with %d positions, %d connections, %d triangles"%(mesh, len(meshes[mesh].positions), len(meshes[mesh].connections), len(meshes[mesh].triangles)))

    
