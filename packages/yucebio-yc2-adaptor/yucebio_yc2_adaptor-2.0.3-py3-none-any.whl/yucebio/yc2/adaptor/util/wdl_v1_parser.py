
# This file was generated by Hermes Parser Generator on Tue Feb  2 16:25:32 2021
# 
# Hermes command: hermes generate --name wdl --header -l python -m .\grammar\wdl.hgr
# Run from: . (relative to this file)
# Hermes version: hermes-parser 2.0rc6
# 
# !!! DO NOT CHANGE THIS FILE DIRECTLY !!!
# 
# If you wish to change something in this file, either change the grammar and
# re-generate this file, or change the templates in Hermes and regenerate.
# See the Hermes repository: http://github.com/scottfrazer/hermes
import sys
import os
import re
import base64
import argparse
from collections import OrderedDict
# Common Code #
def parse_tree_string(parsetree, indent=None, b64_source=True, indent_level=0, debug=False):
    indent_str = (' ' * indent * indent_level) if indent else ''
    if isinstance(parsetree, ParseTree):
        children = [parse_tree_string(child, indent, b64_source, indent_level+1, debug) for child in parsetree.children]
        debug_str = parsetree.debug_str() if debug else ''
        if indent is None or len(children) == 0:
            return '{0}({1}: {2}{3})'.format(indent_str, parsetree.nonterminal, debug_str, ', '.join(children))
        else:
            return '{0}({1}:{2}\n{3}\n{4})'.format(
                indent_str,
                parsetree.nonterminal,
                debug_str,
                ',\n'.join(children),
                indent_str
            )
    elif isinstance(parsetree, Terminal):
        return indent_str + parsetree.dumps(b64_source=b64_source)
def ast_string(ast, indent=None, b64_source=True, indent_level=0):
    indent_str = (' ' * indent * indent_level) if indent else ''
    next_indent_str = (' ' * indent * (indent_level+1)) if indent else ''
    if isinstance(ast, Ast):
        children = OrderedDict([(k, ast_string(v, indent, b64_source, indent_level+1)) for k, v in ast.attributes.items()])
        if indent is None:
            return '({0}: {1})'.format(
                ast.name,
                ', '.join('{0}={1}'.format(k, v) for k, v in children.items())
            )
        else:
            return '({0}:\n{1}\n{2})'.format(
                ast.name,
                ',\n'.join(['{0}{1}={2}'.format(next_indent_str, k, v) for k, v in children.items()]),
                indent_str
            )
    elif isinstance(ast, list):
        children = [ast_string(element, indent, b64_source, indent_level+1) for element in ast]
        if indent is None or len(children) == 0:
            return '[{0}]'.format(', '.join(children))
        else:
            return '[\n{1}\n{0}]'.format(
                indent_str,
                ',\n'.join(['{0}{1}'.format(next_indent_str, child) for child in children]),
            )
    elif isinstance(ast, Terminal):
        return ast.dumps(b64_source=b64_source)
class Terminal:
  def __init__(self, id, str, source_string, resource, line, col):
      self.__dict__.update(locals())
  def getId(self):
      return self.id
  def ast(self):
      return self
  def dumps(self, b64_source=True, **kwargs):
      source_string = base64.b64encode(self.source_string.encode('utf-8')).decode('utf-8') if b64_source else self.source_string
      return '<{resource}:{line}:{col} {terminal} "{source}">'.format(
          resource=self.resource,
          line=self.line,
          col=self.col,
          terminal=self.str,
          source=source_string
      )
  def __str__(self):
      return self.dumps()
class NonTerminal():
  def __init__(self, id, str):
    self.__dict__.update(locals())
    self.list = False
  def __str__(self):
    return self.str
class AstTransform:
  pass
class AstTransformSubstitution(AstTransform):
  def __init__(self, idx):
    self.__dict__.update(locals())
  def __repr__(self):
    return '$' + str(self.idx)
  def __str__(self):
    return self.__repr__()
class AstTransformNodeCreator(AstTransform):
  def __init__( self, name, parameters ):
    self.__dict__.update(locals())
  def __repr__( self ):
    return self.name + '( ' + ', '.join(['%s=$%s' % (k,str(v)) for k,v in self.parameters.items()]) + ' )'
  def __str__(self):
    return self.__repr__()
class AstList(list):
  def ast(self):
      retval = []
      for ast in self:
          retval.append(ast.ast())
      return retval
  def dumps(self, indent=None, b64_source=True):
      args = locals()
      del args['self']
      return ast_string(self, **args)
class ParseTree():
  def __init__(self, nonterminal):
      self.__dict__.update(locals())
      self.children = []
      self.astTransform = None
      self.isExpr = False
      self.isNud = False
      self.isPrefix = False
      self.isInfix = False
      self.nudMorphemeCount = 0
      self.isExprNud = False # true for rules like _expr := {_expr} + {...}
      self.list_separator_id = None
      self.list = False
  def debug_str(self):
      from copy import deepcopy
      def h(v):
          if v == False or v is None:
              return str(v)
          from xtermcolor import colorize
          return colorize(str(v), ansi=190)
      d = deepcopy(self.__dict__)
      for key in ['self', 'nonterminal', 'children']:
          del d[key]
      f = {k: v for k, v in d.items() if v != False and v is not None}
      return ' [{}]'.format(', '.join(['{}={}'.format(k,h(v)) for k,v in f.items()]))
  def add(self, tree):
      self.children.append( tree )
  def is_compound_nud(self):
      return isinstance(self.children[0], ParseTree) and \
             self.children[0].isNud and \
             not self.children[0].isPrefix and \
             not self.isExprNud and \
             not self.isInfix
  def ast(self):
      if self.list == True:
          r = AstList()
          if len(self.children) == 0:
              return r
          for child in self.children:
              if isinstance(child, Terminal) and self.list_separator_id is not None and child.id == self.list_separator_id:
                  continue
              r.append(child.ast())
          return r
      elif self.isExpr:
          if isinstance(self.astTransform, AstTransformSubstitution):
              return self.children[self.astTransform.idx].ast()
          elif isinstance(self.astTransform, AstTransformNodeCreator):
              parameters = OrderedDict()
              for name, idx in self.astTransform.parameters.items():
                  if idx == '$':
                      child = self.children[0]
                  elif self.is_compound_nud():
                      if idx < self.children[0].nudMorphemeCount:
                          child = self.children[0].children[idx]
                      else:
                          index = idx - self.children[0].nudMorphemeCount + 1
                          child = self.children[index]
                  elif len(self.children) == 1 and not isinstance(self.children[0], ParseTree) and not isinstance(self.children[0], list):
                      return self.children[0]
                  else:
                      child = self.children[idx]
                  parameters[name] = child.ast()
              return Ast(self.astTransform.name, parameters)
      else:
          if isinstance(self.astTransform, AstTransformSubstitution):
              return self.children[self.astTransform.idx].ast()
          elif isinstance(self.astTransform, AstTransformNodeCreator):
              parameters = OrderedDict()
              for name, idx in self.astTransform.parameters.items():
                  parameters[name] = self.children[idx].ast()
              return Ast(self.astTransform.name, parameters)
          elif len(self.children):
              return self.children[0].ast()
          else:
              return None
  def dumps(self, indent=None, b64_source=True, debug=False):
      args = locals()
      del args['self']
      return parse_tree_string(self, **args)
class Ast():
    def __init__(self, name, attributes):
        self.__dict__.update(locals())
    def attr(self, attr):
        return self.attributes[attr]
    def dumps(self, indent=None, b64_source=True):
        args = locals()
        del args['self']
        return ast_string(self, **args)
class SyntaxError(Exception):
    def __init__(self, message):
        self.__dict__.update(locals())
    def __str__(self):
        return self.message
class TokenStream(list):
    def __init__(self, arg=[]):
        super(TokenStream, self).__init__(arg)
        self.index = 0
    def advance(self):
        self.index += 1
        return self.current()
    def last(self):
        return self[-1]
    def current(self):
        try:
            return self[self.index]
        except IndexError:
            return None
class DefaultSyntaxErrorHandler:
    def __init__(self):
        self.errors = []
    def _error(self, string):
        error = SyntaxError(string)
        self.errors.append(error)
        return error
    def unexpected_eof(self):
        return self._error("Error: unexpected end of file")
    def excess_tokens(self):
        return self._error("Finished parsing without consuming all tokens.")
    def unexpected_symbol(self, nonterminal, actual_terminal, expected_terminals, rule):
        return self._error("Unexpected symbol (line {line}, col {col}) when parsing parse_{nt}.  Expected {expected}, got {actual}.".format(
            line=actual_terminal.line,
            col=actual_terminal.col,
            nt=nonterminal,
            expected=', '.join(expected_terminals),
            actual=actual_terminal
        ))
    def no_more_tokens(self, nonterminal, expected_terminal, last_terminal):
        return self._error("No more tokens.  Expecting " + expected_terminal)
    def invalid_terminal(self, nonterminal, invalid_terminal):
        return self._error("Invalid symbol ID: {} ({})".format(invalid_terminal.id, invalid_terminal.string))
    def unrecognized_token(self, string, line, col):
        lines = string.split('\n')
        bad_line = lines[line-1]
        return self._error('Unrecognized token on line {}, column {}:\n\n{}\n{}'.format(
            line, col, bad_line, ''.join([' ' for x in range(col-1)]) + '^'
        ))
    def missing_list_items(self, method, required, found, last):
        return self._error("List for {} requires {} items but only {} were found.".format(method, required, found))
    def missing_terminator(self, method, terminator, last):
        return self._error("List for "+method+" is missing a terminator")
class ParserContext:
  def __init__(self, tokens, errors):
    self.__dict__.update(locals())
    self.nonterminal_string = None
    self.rule_string = None
# Parser Code #
terminals = {
    0: 'else',
    1: 'gteq',
    2: 'not_equal',
    3: 'in',
    4: 'colon',
    5: 'lparen',
    6: 'asterisk',
    7: 'object',
    8: 'identifier',
    9: 'null',
    10: 'plus',
    11: 'cmd_attr_hint',
    12: 'if',
    13: 'dot',
    14: 'version_name',
    15: 'meta_value',
    16: 'double_pipe',
    17: 'quote',
    18: 'e',
    19: 'workflow',
    20: 'boolean',
    21: 'call',
    22: 'percent',
    23: 'raw_cmd_start',
    24: 'lt',
    25: 'import',
    26: 'output',
    27: 'fqn',
    28: 'as',
    29: 'input',
    30: 'runtime',
    31: 'while',
    32: 'struct',
    33: 'alias',
    34: 'double_ampersand',
    35: 'rbrace',
    36: 'expression_placeholder_end',
    37: 'rparen',
    38: 'double_equal',
    39: 'dash',
    40: 'slash',
    41: 'parameter_meta',
    42: 'type',
    43: 'lsquare',
    44: 'version',
    45: 'float',
    46: 'qmark',
    47: 'raw_command',
    48: 'task',
    49: 'expression_placeholder_start',
    50: 'integer',
    51: 'raw_cmd_end',
    52: 'lbrace',
    53: 'equal',
    54: 'meta',
    55: 'cmd_part',
    56: 'gt',
    57: 'comma',
    58: 'string',
    59: 'then',
    60: 'rsquare',
    61: 'not',
    62: 'type_e',
    63: 'lteq',
    64: 'scatter',
    'else': 0,
    'gteq': 1,
    'not_equal': 2,
    'in': 3,
    'colon': 4,
    'lparen': 5,
    'asterisk': 6,
    'object': 7,
    'identifier': 8,
    'null': 9,
    'plus': 10,
    'cmd_attr_hint': 11,
    'if': 12,
    'dot': 13,
    'version_name': 14,
    'meta_value': 15,
    'double_pipe': 16,
    'quote': 17,
    'e': 18,
    'workflow': 19,
    'boolean': 20,
    'call': 21,
    'percent': 22,
    'raw_cmd_start': 23,
    'lt': 24,
    'import': 25,
    'output': 26,
    'fqn': 27,
    'as': 28,
    'input': 29,
    'runtime': 30,
    'while': 31,
    'struct': 32,
    'alias': 33,
    'double_ampersand': 34,
    'rbrace': 35,
    'expression_placeholder_end': 36,
    'rparen': 37,
    'double_equal': 38,
    'dash': 39,
    'slash': 40,
    'parameter_meta': 41,
    'type': 42,
    'lsquare': 43,
    'version': 44,
    'float': 45,
    'qmark': 46,
    'raw_command': 47,
    'task': 48,
    'expression_placeholder_start': 49,
    'integer': 50,
    'raw_cmd_end': 51,
    'lbrace': 52,
    'equal': 53,
    'meta': 54,
    'cmd_part': 55,
    'gt': 56,
    'comma': 57,
    'string': 58,
    'then': 59,
    'rsquare': 60,
    'not': 61,
    'type_e': 62,
    'lteq': 63,
    'scatter': 64,
}
# table[nonterminal][terminal] = rule
table = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, 73, -1, -1, 73, -1, 73, -1, -1, -1, 73, -1, -1, -1, -1, -1, 73, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, 73, -1, -1, -1, -1, -1, -1, -1, 73, -1, 73],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 79, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, 18, -1, -1, 17, -1, -1, -1, 18, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, 26, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 31, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, 55, -1, 55, 55, -1, 55, -1, 55, -1, -1, -1, -1, 55, 55, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, 55, -1, 55, -1, -1, -1, -1, 55, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, 67, -1, -1, 66, -1, 63, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, 62, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, 62, -1, 65],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 35, -1, -1, -1, -1, -1, 34, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 85],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, 71, -1, 70, 71, -1, 71, -1, -1, -1, 71, -1, -1, -1, -1, -1, 71, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, 71, -1, -1, -1, -1, -1, -1, -1, 71, -1, 71],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
]
nonterminal_first = {
    65: [12],
    66: [52],
    67: [-1, 62, 8, 42],
    68: [-1, 52],
    69: [19],
    70: [-1, 25],
    71: [62, 8, 42],
    72: [17],
    73: [41],
    74: [29],
    75: [28],
    76: [-1, 28],
    77: [11],
    78: [21],
    79: [58, -1, 49],
    80: [62, 8, 42],
    81: [-1, 29],
    82: [-1, 8],
    83: [48],
    84: [-1, 55, 49],
    85: [5, 39, 7, 10, 8, 43, 12, 45, -1, 50, 18, 17, 20, 52, 61],
    86: [-1, 8],
    87: [17],
    88: [-1, 62, 8, 42],
    89: [5, 39, 7, 8, 10, 43, 12, 45, -1, 50, 18, 17, 20, 52, 61],
    90: [54],
    91: [32],
    92: [31],
    93: [62, 8, 42],
    94: [47],
    95: [-1, 62, 8, 42],
    96: [8],
    97: [29],
    98: [-1, 62, 8, 42],
    99: [52],
    100: [52],
    101: [62, 8, 42],
    102: [8],
    103: [8],
    104: [19, 48, 32],
    105: [-1, 8],
    106: [20, 43, 45, 52, 15, 9, 50, 17],
    107: [62, 8, 42],
    108: [-1, 8],
    109: [25],
    110: [8],
    111: [-1, 8],
    112: [-1, 58],
    113: [29, 54, 8, 41, 26, 47, 62, 30, 42],
    114: [54],
    115: [29, 8, 41, 12, -1, 31, 21, 54, 26, 64, 62, 42],
    116: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    117: [-1, 53],
    118: [21, 54, 62, 8, 41, 26, 12, 64, 31, 29, 42],
    119: [49],
    120: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    121: [28],
    122: [44],
    123: [-1, 11],
    124: [9, 43, 45, -1, 15, 50, 17, 20, 52],
    125: [33],
    126: [49, 58],
    127: [26],
    128: [30],
    129: [-1, 33],
    130: [-1, 19, 48, 32],
    131: [55, 49],
    132: [64],
    133: [41],
    134: [-1, 28],
    135: [44],
    136: [47, 29, 54, 8, 41, 26, -1, 62, 30, 42],
    137: [53],
}
nonterminal_follow = {
    65: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    66: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    67: [60],
    68: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    69: [19, -1, 48, 32],
    70: [19, -1, 48, 32],
    71: [42, 35, 62, 8],
    72: [19, 35, 25, 48, 8, 57, 60, -1, 28, 32],
    73: [35, 62, 8, 41, 47, 54, 26, 29, 30, 42],
    74: [35],
    75: [33, 19, 25, -1, 48, 32],
    76: [33, 19, -1, 48, 25, 32],
    77: [5, 39, 7, 8, 10, 43, 11, 12, 45, 50, 18, 17, 20, 52, 61],
    78: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    79: [17],
    80: [35, 62, 8, 41, 12, 47, 31, 21, 54, 26, 64, 29, 30, 42],
    81: [35],
    82: [35],
    83: [19, -1, 48, 32],
    84: [51],
    85: [37, 60],
    86: [35],
    87: [1, 2, 5, 6, 7, 8, 12, 16, 17, 24, 31, 36, 35, 38, 40, 41, 45, 47, 50, 54, 56, 57, 60, 61, 62, 42, 0, 64, 4, 10, 11, 13, 18, 20, 21, 22, 26, 29, 30, 39, 37, 43, 52, 59, 34, 63],
    88: [35],
    89: [35],
    90: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    91: [19, -1, 48, 32],
    92: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    93: [57, 60, 8],
    94: [35, 62, 8, 41, 47, 54, 26, 29, 30, 42],
    95: [35],
    96: [57, 35],
    97: [35, 62, 8, 41, 12, 47, 31, 21, 54, 26, 64, 29, 30, 42],
    98: [35],
    99: [35, 62, 8, 41, 47, 54, 26, 29, 30, 42],
    100: [35, 62, 8, 41, 12, 47, 31, 21, 54, 26, 64, 29, 30, 42],
    101: [42, 35, 62, 8],
    102: [57, 35, 8],
    103: [57, 35],
    104: [19, -1, 48, 32],
    105: [35],
    106: [57, 60, 35, 8],
    107: [42, 35, 62, 8],
    108: [35],
    109: [19, -1, 48, 25, 32],
    110: [35, 8],
    111: [35],
    112: [17],
    113: [35, 62, 8, 41, 47, 54, 26, 29, 30, 42],
    114: [35, 62, 8, 41, 47, 54, 26, 29, 30, 42],
    115: [35],
    116: [57, 35],
    117: [42, 35, 62, 8],
    118: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    119: [51, 58, 55, 49, 17],
    120: [0, 1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 18, 17, 20, 21, 22, 64, 24, 26, 29, 34, 30, 31, 36, 39, 37, 38, 35, 40, 41, 43, 45, 47, 50, 52, 54, 56, 57, 59, 60, 61, 62, 63, 42],
    121: [35, 62, 8, 41, 12, 31, 21, 52, 54, 26, 64, 29, 42],
    122: [-1, 25],
    123: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    124: [60],
    125: [33, 19, 25, -1, 48, 32],
    126: [58, 49, 17],
    127: [35, 62, 8, 41, 12, 47, 31, 21, 54, 26, 64, 29, 30, 42],
    128: [35, 62, 8, 41, 47, 54, 26, 29, 30, 42],
    129: [19, -1, 48, 25, 32],
    130: [-1],
    131: [51, 55, 49],
    132: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    133: [29, 35, 8, 41, 42, 12, 31, 21, 54, 26, 62, 64],
    134: [35, 62, 8, 41, 12, 31, 21, 52, 54, 26, 64, 29, 42],
    135: [-1],
    136: [35],
    137: [35, 62, 8, 41, 12, 47, 31, 21, 54, 26, 64, 29, 30, 42],
}
rule_first = {
    0: [-1, 25],
    1: [-1, 19, 48, 32],
    2: [44],
    3: [19],
    4: [48],
    5: [32],
    6: [44],
    7: [-1, 62, 8, 42],
    8: [32],
    9: [42, 62, 8],
    10: [58],
    11: [-1],
    12: [17],
    13: [-1, 49, 58],
    14: [17],
    15: [58],
    16: [49],
    17: [28],
    18: [-1],
    19: [33, -1],
    20: [25],
    21: [28],
    22: [33],
    23: [-1, 29, 54, 8, 41, 26, 47, 62, 30, 42],
    24: [48],
    25: [47],
    26: [29],
    27: [26],
    28: [30],
    29: [41],
    30: [54],
    31: [42, 62, 8],
    32: [-1, 55, 49],
    33: [47],
    34: [55],
    35: [49],
    36: [-1, 11],
    37: [49],
    38: [11],
    39: [-1, 62, 8, 42],
    40: [29],
    41: [30],
    42: [-1, 8],
    43: [52],
    44: [8],
    45: [54],
    46: [41],
    47: [-1, 8],
    48: [52],
    49: [8],
    50: [53],
    51: [-1],
    52: [42, 62, 8],
    53: [42, 62, 8],
    54: [53],
    55: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    56: [-1, 62, 8, 42],
    57: [26],
    58: [42, 62, 8],
    59: [21, 54, 62, 8, 41, 26, 12, 64, -1, 31, 29, 42],
    60: [19],
    61: [21],
    62: [42, 62, 8],
    63: [31],
    64: [12],
    65: [64],
    66: [29],
    67: [26],
    68: [41],
    69: [54],
    70: [28],
    71: [-1],
    72: [52],
    73: [-1],
    74: [21],
    75: [29],
    76: [-1],
    77: [52],
    78: [-1, 8],
    79: [29],
    80: [28],
    81: [41],
    82: [54],
    83: [31],
    84: [12],
    85: [64],
    86: [8],
    87: [8],
    88: [17],
    89: [20],
    90: [50],
    91: [45],
    92: [9],
    93: [20, 52, 9, 43, 45, -1, 15, 50, 17],
    94: [43],
    95: [-1, 8],
    96: [52],
    97: [-1, 62, 8, 42],
    98: [42],
    99: [42],
    100: [42],
    101: [42],
    102: [8],
    103: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    104: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    105: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    106: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    107: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    108: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    109: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    110: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    111: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    112: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    113: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    114: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    115: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    116: [61],
    117: [10],
    118: [39],
    119: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, -1, 61, 50, 18],
    120: [8],
    121: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    122: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, 61, 50, 18],
    123: [-1, 8],
    124: [7],
    125: [43],
    126: [20, 52, 5, 39, 7, 8, 10, 43, 17, 12, 45, -1, 61, 50, 18],
    127: [52],
    128: [5],
    129: [12],
    130: [17],
    131: [8],
    132: [20],
    133: [50],
    134: [45],
}
nonterminal_rules = {
    65: [
        "$if_stmt = :if :lparen $e :rparen :lbrace $_gen15 :rbrace -> If( expression=$2, body=$5 )",
    ],
    66: [
        "$call_brace_block = :lbrace $_gen18 :rbrace -> $1",
    ],
    67: [
        "$_gen22 = list($type_e, :comma)",
    ],
    68: [
        "$_gen17 = $call_brace_block",
        "$_gen17 = :_empty",
    ],
    69: [
        "$workflow = :workflow :identifier :lbrace $_gen15 :rbrace -> Workflow( name=$1, body=$3 )",
    ],
    70: [
        "$_gen0 = list($import)",
    ],
    71: [
        "$struct_declaration = $type_e :identifier -> StructEntry( type=$0, name=$1 )",
    ],
    72: [
        "$static_string = :quote $_gen3 :quote -> StaticString( value=$1 )",
    ],
    73: [
        "$parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
    ],
    74: [
        "$call_body = :input :colon $_gen19 -> CallBody( inputs=$2 )",
    ],
    75: [
        "$import_namespace = :as :identifier -> $1",
    ],
    76: [
        "$_gen5 = $import_namespace",
        "$_gen5 = :_empty",
    ],
    77: [
        "$expression_placeholder_kv = :cmd_attr_hint :identifier :equal $e -> ExpressionPlaceholderAttr( key=$1, value=$3 )",
    ],
    78: [
        "$call = :call :fqn $_gen16 $_gen17 -> Call( task=$1, alias=$2, body=$3 )",
    ],
    79: [
        "$_gen4 = list($string_piece)",
    ],
    80: [
        "$declaration = $type_e :identifier $setter -> Declaration( type=$0, name=$1, expression=$2 )",
    ],
    81: [
        "$_gen18 = $call_body",
        "$_gen18 = :_empty",
    ],
    82: [
        "$_gen19 = list($input_kv, :comma)",
    ],
    83: [
        "$task = :task :identifier :lbrace $_gen7 :rbrace -> Task( name=$1, sections=$3 )",
    ],
    84: [
        "$_gen8 = list($command_part)",
    ],
    85: [
        "$_gen23 = list($e, :comma)",
    ],
    86: [
        "$_gen21 = list($meta_kv, :comma)",
    ],
    87: [
        "$string_literal = :quote $_gen4 :quote -> StringLiteral( pieces=$1 )",
    ],
    88: [
        "$_gen10 = list($input_declaration)",
    ],
    89: [
        "$_gen25 = list($map_kv, :comma)",
    ],
    90: [
        "$wf_meta = :meta $meta_map -> Meta( map=$1 )",
    ],
    91: [
        "$struct = :struct :identifier :lbrace $_gen2 :rbrace -> Struct( name=$1, entries=$3 )",
    ],
    92: [
        "$while_loop = :while :lparen $e :rparen :lbrace $_gen15 :rbrace -> WhileLoop( expression=$2, body=$5 )",
    ],
    93: [
        "$type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )",
        "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
        "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
        "$type_e = :type",
        "$type_e = :identifier",
    ],
    94: [
        "$command = :raw_command :raw_cmd_start $_gen8 :raw_cmd_end -> RawCommand( parts=$2 )",
    ],
    95: [
        "$_gen14 = list($output_kv)",
    ],
    96: [
        "$input_kv = :identifier :equal $e -> ObjectKV( key=$0, value=$2 )",
    ],
    97: [
        "$inputs = :input :lbrace $_gen10 :rbrace -> Inputs( inputs=$2 )",
    ],
    98: [
        "$_gen2 = list($struct_declaration)",
    ],
    99: [
        "$rt_map = :lbrace $_gen11 :rbrace -> $1",
    ],
    100: [
        "$meta_map = :lbrace $_gen12 :rbrace -> $1",
    ],
    101: [
        "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
    ],
    102: [
        "$meta_kv = :identifier :colon $meta_value -> MetaKvPair( key=$0, value=$2 )",
    ],
    103: [
        "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
    ],
    104: [
        "$file_body_element = $workflow",
        "$file_body_element = $task",
        "$file_body_element = $struct",
    ],
    105: [
        "$_gen11 = list($kv)",
    ],
    106: [
        "$meta_value = $static_string",
        "$meta_value = :boolean",
        "$meta_value = :integer",
        "$meta_value = :float",
        "$meta_value = :null",
        "$meta_value = :lsquare $_gen20 :rsquare -> MetaArray( values=$1 )",
        "$meta_value = :lbrace $_gen21 :rbrace -> MetaObject( map=$1 )",
    ],
    107: [
        "$input_declaration = $type_e :identifier $_gen13 -> InputDeclaration( type=$0, name=$1, expression=$2 )",
    ],
    108: [
        "$_gen12 = list($meta_kv)",
    ],
    109: [
        "$import = :import $static_string $_gen5 $_gen6 -> Import( uri=$1, namespace=$2, aliases=$3 )",
    ],
    110: [
        "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
    ],
    111: [
        "$_gen24 = list($object_kv, :comma)",
    ],
    112: [
        "$_gen3 = :string",
        "$_gen3 = :_empty",
    ],
    113: [
        "$task_sections = $command",
        "$task_sections = $inputs",
        "$task_sections = $outputs",
        "$task_sections = $runtime",
        "$task_sections = $parameter_meta",
        "$task_sections = $meta",
        "$task_sections = $declaration",
    ],
    114: [
        "$meta = :meta $meta_map -> Meta( map=$1 )",
    ],
    115: [
        "$_gen15 = list($wf_body_element)",
    ],
    116: [
        "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
    ],
    117: [
        "$_gen13 = $setter",
        "$_gen13 = :_empty",
    ],
    118: [
        "$wf_body_element = $call",
        "$wf_body_element = $declaration",
        "$wf_body_element = $while_loop",
        "$wf_body_element = $if_stmt",
        "$wf_body_element = $scatter",
        "$wf_body_element = $inputs",
        "$wf_body_element = $outputs",
        "$wf_body_element = $wf_parameter_meta",
        "$wf_body_element = $wf_meta",
    ],
    119: [
        "$expression_placeholder = :expression_placeholder_start $_gen9 $e :expression_placeholder_end -> ExpressionPlaceholder( attributes=$1, expr=$2 )",
    ],
    120: [
        "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
        "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
        "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
        "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
        "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
        "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
        "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
        "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
        "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
        "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
        "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
        "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
        "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
        "$e = :not $e -> LogicalNot( expression=$1 )",
        "$e = :plus $e -> UnaryPlus( expression=$1 )",
        "$e = :dash $e -> UnaryNegation( expression=$1 )",
        "$e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )",
        "$e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
        "$e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )",
        "$e = :object :lbrace $_gen24 :rbrace -> ObjectLiteral( map=$2 )",
        "$e = :lsquare $_gen23 :rsquare -> ArrayLiteral( values=$1 )",
        "$e = :lbrace $_gen25 :rbrace -> MapLiteral( map=$1 )",
        "$e = :lparen $_gen23 :rparen -> TupleLiteral( values=$1 )",
        "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
        "$e = $string_literal",
        "$e = :identifier",
        "$e = :boolean",
        "$e = :integer",
        "$e = :float",
    ],
    121: [
        "$alias = :as :identifier -> $1",
    ],
    122: [
        "$version = :version :version_name -> VersionDeclaration( v=$1 )",
    ],
    123: [
        "$_gen9 = list($expression_placeholder_kv)",
    ],
    124: [
        "$_gen20 = list($meta_value, :comma)",
    ],
    125: [
        "$import_alias = :alias :identifier :as :identifier -> ImportAlias( old_name=$1, new_name=$3 )",
    ],
    126: [
        "$string_piece = :string",
        "$string_piece = $expression_placeholder",
    ],
    127: [
        "$outputs = :output :lbrace $_gen14 :rbrace -> Outputs( outputs=$2 )",
    ],
    128: [
        "$runtime = :runtime $rt_map -> Runtime( map=$1 )",
    ],
    129: [
        "$_gen6 = list($import_alias)",
    ],
    130: [
        "$_gen1 = list($file_body_element)",
    ],
    131: [
        "$command_part = :cmd_part",
        "$command_part = $expression_placeholder",
    ],
    132: [
        "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen15 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
    ],
    133: [
        "$wf_parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
    ],
    134: [
        "$_gen16 = $alias",
        "$_gen16 = :_empty",
    ],
    135: [
        "$document = $version $_gen0 $_gen1 -> Draft3File( version=$0, imports=$1, body=$2 )",
    ],
    136: [
        "$_gen7 = list($task_sections)",
    ],
    137: [
        "$setter = :equal $e -> $1",
    ],
}
rules = {
    0: "$_gen0 = list($import)",
    1: "$_gen1 = list($file_body_element)",
    2: "$document = $version $_gen0 $_gen1 -> Draft3File( version=$0, imports=$1, body=$2 )",
    3: "$file_body_element = $workflow",
    4: "$file_body_element = $task",
    5: "$file_body_element = $struct",
    6: "$version = :version :version_name -> VersionDeclaration( v=$1 )",
    7: "$_gen2 = list($struct_declaration)",
    8: "$struct = :struct :identifier :lbrace $_gen2 :rbrace -> Struct( name=$1, entries=$3 )",
    9: "$struct_declaration = $type_e :identifier -> StructEntry( type=$0, name=$1 )",
    10: "$_gen3 = :string",
    11: "$_gen3 = :_empty",
    12: "$static_string = :quote $_gen3 :quote -> StaticString( value=$1 )",
    13: "$_gen4 = list($string_piece)",
    14: "$string_literal = :quote $_gen4 :quote -> StringLiteral( pieces=$1 )",
    15: "$string_piece = :string",
    16: "$string_piece = $expression_placeholder",
    17: "$_gen5 = $import_namespace",
    18: "$_gen5 = :_empty",
    19: "$_gen6 = list($import_alias)",
    20: "$import = :import $static_string $_gen5 $_gen6 -> Import( uri=$1, namespace=$2, aliases=$3 )",
    21: "$import_namespace = :as :identifier -> $1",
    22: "$import_alias = :alias :identifier :as :identifier -> ImportAlias( old_name=$1, new_name=$3 )",
    23: "$_gen7 = list($task_sections)",
    24: "$task = :task :identifier :lbrace $_gen7 :rbrace -> Task( name=$1, sections=$3 )",
    25: "$task_sections = $command",
    26: "$task_sections = $inputs",
    27: "$task_sections = $outputs",
    28: "$task_sections = $runtime",
    29: "$task_sections = $parameter_meta",
    30: "$task_sections = $meta",
    31: "$task_sections = $declaration",
    32: "$_gen8 = list($command_part)",
    33: "$command = :raw_command :raw_cmd_start $_gen8 :raw_cmd_end -> RawCommand( parts=$2 )",
    34: "$command_part = :cmd_part",
    35: "$command_part = $expression_placeholder",
    36: "$_gen9 = list($expression_placeholder_kv)",
    37: "$expression_placeholder = :expression_placeholder_start $_gen9 $e :expression_placeholder_end -> ExpressionPlaceholder( attributes=$1, expr=$2 )",
    38: "$expression_placeholder_kv = :cmd_attr_hint :identifier :equal $e -> ExpressionPlaceholderAttr( key=$1, value=$3 )",
    39: "$_gen10 = list($input_declaration)",
    40: "$inputs = :input :lbrace $_gen10 :rbrace -> Inputs( inputs=$2 )",
    41: "$runtime = :runtime $rt_map -> Runtime( map=$1 )",
    42: "$_gen11 = list($kv)",
    43: "$rt_map = :lbrace $_gen11 :rbrace -> $1",
    44: "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
    45: "$meta = :meta $meta_map -> Meta( map=$1 )",
    46: "$parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
    47: "$_gen12 = list($meta_kv)",
    48: "$meta_map = :lbrace $_gen12 :rbrace -> $1",
    49: "$meta_kv = :identifier :colon $meta_value -> MetaKvPair( key=$0, value=$2 )",
    50: "$_gen13 = $setter",
    51: "$_gen13 = :_empty",
    52: "$input_declaration = $type_e :identifier $_gen13 -> InputDeclaration( type=$0, name=$1, expression=$2 )",
    53: "$declaration = $type_e :identifier $setter -> Declaration( type=$0, name=$1, expression=$2 )",
    54: "$setter = :equal $e -> $1",
    55: "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
    56: "$_gen14 = list($output_kv)",
    57: "$outputs = :output :lbrace $_gen14 :rbrace -> Outputs( outputs=$2 )",
    58: "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
    59: "$_gen15 = list($wf_body_element)",
    60: "$workflow = :workflow :identifier :lbrace $_gen15 :rbrace -> Workflow( name=$1, body=$3 )",
    61: "$wf_body_element = $call",
    62: "$wf_body_element = $declaration",
    63: "$wf_body_element = $while_loop",
    64: "$wf_body_element = $if_stmt",
    65: "$wf_body_element = $scatter",
    66: "$wf_body_element = $inputs",
    67: "$wf_body_element = $outputs",
    68: "$wf_body_element = $wf_parameter_meta",
    69: "$wf_body_element = $wf_meta",
    70: "$_gen16 = $alias",
    71: "$_gen16 = :_empty",
    72: "$_gen17 = $call_brace_block",
    73: "$_gen17 = :_empty",
    74: "$call = :call :fqn $_gen16 $_gen17 -> Call( task=$1, alias=$2, body=$3 )",
    75: "$_gen18 = $call_body",
    76: "$_gen18 = :_empty",
    77: "$call_brace_block = :lbrace $_gen18 :rbrace -> $1",
    78: "$_gen19 = list($input_kv, :comma)",
    79: "$call_body = :input :colon $_gen19 -> CallBody( inputs=$2 )",
    80: "$alias = :as :identifier -> $1",
    81: "$wf_parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
    82: "$wf_meta = :meta $meta_map -> Meta( map=$1 )",
    83: "$while_loop = :while :lparen $e :rparen :lbrace $_gen15 :rbrace -> WhileLoop( expression=$2, body=$5 )",
    84: "$if_stmt = :if :lparen $e :rparen :lbrace $_gen15 :rbrace -> If( expression=$2, body=$5 )",
    85: "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen15 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
    86: "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
    87: "$input_kv = :identifier :equal $e -> ObjectKV( key=$0, value=$2 )",
    88: "$meta_value = $static_string",
    89: "$meta_value = :boolean",
    90: "$meta_value = :integer",
    91: "$meta_value = :float",
    92: "$meta_value = :null",
    93: "$_gen20 = list($meta_value, :comma)",
    94: "$meta_value = :lsquare $_gen20 :rsquare -> MetaArray( values=$1 )",
    95: "$_gen21 = list($meta_kv, :comma)",
    96: "$meta_value = :lbrace $_gen21 :rbrace -> MetaObject( map=$1 )",
    97: "$_gen22 = list($type_e, :comma)",
    98: "$type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )",
    99: "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
    100: "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
    101: "$type_e = :type",
    102: "$type_e = :identifier",
    103: "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
    104: "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
    105: "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
    106: "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
    107: "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
    108: "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
    109: "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
    110: "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
    111: "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
    112: "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
    113: "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
    114: "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
    115: "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
    116: "$e = :not $e -> LogicalNot( expression=$1 )",
    117: "$e = :plus $e -> UnaryPlus( expression=$1 )",
    118: "$e = :dash $e -> UnaryNegation( expression=$1 )",
    119: "$_gen23 = list($e, :comma)",
    120: "$e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )",
    121: "$e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
    122: "$e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )",
    123: "$_gen24 = list($object_kv, :comma)",
    124: "$e = :object :lbrace $_gen24 :rbrace -> ObjectLiteral( map=$2 )",
    125: "$e = :lsquare $_gen23 :rsquare -> ArrayLiteral( values=$1 )",
    126: "$_gen25 = list($map_kv, :comma)",
    127: "$e = :lbrace $_gen25 :rbrace -> MapLiteral( map=$1 )",
    128: "$e = :lparen $_gen23 :rparen -> TupleLiteral( values=$1 )",
    129: "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
    130: "$e = $string_literal",
    131: "$e = :identifier",
    132: "$e = :boolean",
    133: "$e = :integer",
    134: "$e = :float",
}
def is_terminal(id): return isinstance(id, int) and 0 <= id <= 64
def parse(tokens, errors=None, start=None):
    if errors is None:
        errors = DefaultSyntaxErrorHandler()
    if isinstance(tokens, str):
        tokens = lex(tokens, 'string', errors)
    ctx = ParserContext(tokens, errors)
    tree = parse_document(ctx)
    if tokens.current() != None:
        raise ctx.errors.excess_tokens()
    return tree
def expect(ctx, terminal_id):
    current = ctx.tokens.current()
    if not current:
        raise ctx.errors.no_more_tokens(ctx.nonterminal, terminals[terminal_id], ctx.tokens.last())
    if current.id != terminal_id:
        raise ctx.errors.unexpected_symbol(ctx.nonterminal, current, [terminals[terminal_id]], ctx.rule)
    next = ctx.tokens.advance()
    if next and not is_terminal(next.id):
        raise ctx.errors.invalid_terminal(ctx.nonterminal, next)
    return current
# START definitions for expression parser: e
infix_binding_power_e = {
    16: 4000, # $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
    34: 5000, # $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
    38: 6000, # $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
    2: 6000, # $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
    24: 7000, # $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
    63: 7000, # $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
    56: 7000, # $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
    1: 7000, # $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
    10: 8000, # $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
    39: 8000, # $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
    6: 9000, # $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
    40: 9000, # $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
    22: 9000, # $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
    5: 11000, # $e = :identifier <=> :lparen list($e, :comma) :rparen -> FunctionCall( name=$0, params=$2 )
    43: 12000, # $e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
    13: 13000, # $e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )
}
prefix_binding_power_e = {
    61: 10000, # $e = :not $e -> LogicalNot( expression=$1 )
    10: 10000, # $e = :plus $e -> UnaryPlus( expression=$1 )
    39: 10000, # $e = :dash $e -> UnaryNegation( expression=$1 )
}
def get_infix_binding_power_e(terminal_id):
    try:
        return infix_binding_power_e[terminal_id]
    except:
        return 0
def get_prefix_binding_power_e(terminal_id):
    try:
        return prefix_binding_power_e[terminal_id]
    except:
        return 0
def parse_e(ctx):
    return parse_e_internal(ctx, rbp=0)
def parse_e_internal(ctx, rbp=0):
    left = nud_e(ctx)
    if isinstance(left, ParseTree):
        left.isExpr = True
        left.isNud = True
    while ctx.tokens.current() and rbp < get_infix_binding_power_e(ctx.tokens.current().id):
        left = led_e(left, ctx)
    if left:
        left.isExpr = True
    return left
def nud_e(ctx):
    tree = ParseTree(NonTerminal(120, 'e'))
    current = ctx.tokens.current()
    ctx.nonterminal = "e"
    if not current:
        return tree
    elif current.id in rule_first[116]:
        # rule first == not
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :not $e -> LogicalNot( expression=$1 )
        ctx.rule = rules[116]
        ast_parameters = OrderedDict([
            ('expression', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('LogicalNot', ast_parameters)
        tree.nudMorphemeCount = 2
        tree.add(expect(ctx, 61))
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(61)))
        tree.isPrefix = True
    elif current.id in rule_first[117]:
        # rule first == plus
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :plus $e -> UnaryPlus( expression=$1 )
        ctx.rule = rules[117]
        ast_parameters = OrderedDict([
            ('expression', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('UnaryPlus', ast_parameters)
        tree.nudMorphemeCount = 2
        tree.add(expect(ctx, 10))
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(10)))
        tree.isPrefix = True
    elif current.id in rule_first[118]:
        # rule first == dash
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :dash $e -> UnaryNegation( expression=$1 )
        ctx.rule = rules[118]
        ast_parameters = OrderedDict([
            ('expression', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('UnaryNegation', ast_parameters)
        tree.nudMorphemeCount = 2
        tree.add(expect(ctx, 39))
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(39)))
        tree.isPrefix = True
    elif current.id in rule_first[120]:
        # rule first == identifier
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )
        ctx.rule = rules[120]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 8))
    elif current.id in rule_first[124]:
        # rule first == object
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :object :lbrace $_gen24 :rbrace -> ObjectLiteral( map=$2 )
        ctx.rule = rules[124]
        ast_parameters = OrderedDict([
            ('map', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('ObjectLiteral', ast_parameters)
        tree.nudMorphemeCount = 4
        tree.add(expect(ctx, 7))
        tree.add(expect(ctx, 52))
        tree.add(parse__gen24(ctx))
        tree.add(expect(ctx, 35))
    elif current.id in rule_first[125]:
        # rule first == lsquare
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :lsquare $_gen23 :rsquare -> ArrayLiteral( values=$1 )
        ctx.rule = rules[125]
        ast_parameters = OrderedDict([
            ('values', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('ArrayLiteral', ast_parameters)
        tree.nudMorphemeCount = 3
        tree.add(expect(ctx, 43))
        tree.add(parse__gen23(ctx))
        tree.add(expect(ctx, 60))
    elif current.id in rule_first[127]:
        # rule first == lbrace
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :lbrace $_gen25 :rbrace -> MapLiteral( map=$1 )
        ctx.rule = rules[127]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('MapLiteral', ast_parameters)
        tree.nudMorphemeCount = 3
        tree.add(expect(ctx, 52))
        tree.add(parse__gen25(ctx))
        tree.add(expect(ctx, 35))
    elif current.id in rule_first[128]:
        # rule first == lparen
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :lparen $_gen23 :rparen -> TupleLiteral( values=$1 )
        ctx.rule = rules[128]
        ast_parameters = OrderedDict([
            ('values', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('TupleLiteral', ast_parameters)
        tree.nudMorphemeCount = 3
        tree.add(expect(ctx, 5))
        tree.add(parse__gen23(ctx))
        tree.add(expect(ctx, 37))
    elif current.id in rule_first[129]:
        # rule first == if
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )
        ctx.rule = rules[129]
        ast_parameters = OrderedDict([
            ('cond', 1),
            ('iftrue', 3),
            ('iffalse', 5),
        ])
        tree.astTransform = AstTransformNodeCreator('TernaryIf', ast_parameters)
        tree.nudMorphemeCount = 6
        tree.add(expect(ctx, 12))
        tree.add(parse_e(ctx))
        tree.add(expect(ctx, 59))
        tree.add(parse_e(ctx))
        tree.add(expect(ctx, 0))
        tree.add(parse_e(ctx))
    elif current.id in rule_first[130]:
        # rule first == quote
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = $string_literal
        ctx.rule = rules[130]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(parse_string_literal(ctx))
    elif current.id in rule_first[131]:
        # rule first == identifier
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :identifier
        ctx.rule = rules[131]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 8))
    elif current.id in rule_first[132]:
        # rule first == boolean
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :boolean
        ctx.rule = rules[132]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 20))
    elif current.id in rule_first[133]:
        # rule first == integer
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :integer
        ctx.rule = rules[133]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 50))
    elif current.id in rule_first[134]:
        # rule first == float
        # e first == boolean, lbrace, lparen, dash, object, identifier, plus, lsquare, quote, if, float, not, integer, e
        # $e = :float
        ctx.rule = rules[134]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 45))
    return tree
def led_e(left, ctx):
    tree = ParseTree(NonTerminal(120, 'e'))
    current = ctx.tokens.current()
    ctx.nonterminal = "e"
    if current.id == 16: # :double_pipe
        # $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
        ctx.rule = rules[103]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('LogicalOr', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 16)) # :double_pipe
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(16) - modifier))
    if current.id == 34: # :double_ampersand
        # $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
        ctx.rule = rules[104]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('LogicalAnd', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 34)) # :double_ampersand
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(34) - modifier))
    if current.id == 38: # :double_equal
        # $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
        ctx.rule = rules[105]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Equals', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 38)) # :double_equal
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(38) - modifier))
    if current.id == 2: # :not_equal
        # $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
        ctx.rule = rules[106]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('NotEquals', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 2)) # :not_equal
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(2) - modifier))
    if current.id == 24: # :lt
        # $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
        ctx.rule = rules[107]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('LessThan', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 24)) # :lt
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(24) - modifier))
    if current.id == 63: # :lteq
        # $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
        ctx.rule = rules[108]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('LessThanOrEqual', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 63)) # :lteq
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(63) - modifier))
    if current.id == 56: # :gt
        # $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
        ctx.rule = rules[109]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('GreaterThan', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 56)) # :gt
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(56) - modifier))
    if current.id == 1: # :gteq
        # $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
        ctx.rule = rules[110]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('GreaterThanOrEqual', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 1)) # :gteq
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(1) - modifier))
    if current.id == 10: # :plus
        # $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
        ctx.rule = rules[111]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Add', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 10)) # :plus
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(10) - modifier))
    if current.id == 39: # :dash
        # $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
        ctx.rule = rules[112]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Subtract', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 39)) # :dash
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(39) - modifier))
    if current.id == 6: # :asterisk
        # $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
        ctx.rule = rules[113]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Multiply', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 6)) # :asterisk
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(6) - modifier))
    if current.id == 40: # :slash
        # $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
        ctx.rule = rules[114]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Divide', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 40)) # :slash
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(40) - modifier))
    if current.id == 22: # :percent
        # $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
        ctx.rule = rules[115]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Remainder', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 22)) # :percent
        modifier = 0
        tree.isInfix = True
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(22) - modifier))
    if current.id == 5: # :lparen
        # $e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )
        ctx.rule = rules[120]
        ast_parameters = OrderedDict([
            ('name', 0),
            ('params', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('FunctionCall', ast_parameters)
        tree.add(left)
        tree.add(expect(ctx, 5)) # :lparen
        tree.add(parse__gen23(ctx))
        tree.add(expect(ctx, 37)) # :rparen
    if current.id == 43: # :lsquare
        # $e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
        ctx.rule = rules[121]
        ast_parameters = OrderedDict([
            ('lhs', 0),
            ('rhs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('ArrayOrMapLookup', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 43)) # :lsquare
        modifier = 0
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(43) - modifier))
        tree.add(expect(ctx, 60)) # :rsquare
    if current.id == 13: # :dot
        # $e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )
        ctx.rule = rules[122]
        ast_parameters = OrderedDict([
            ('value', 0),
            ('member', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('MemberAccess', ast_parameters)
        tree.isExprNud = True
        tree.add(left)
        tree.add(expect(ctx, 13)) # :dot
        tree.add(expect(ctx, 8)) # :identifier
    return tree
# END definitions for expression parser: e
# START definitions for expression parser: meta_value
infix_binding_power_meta_value = {
}
prefix_binding_power_meta_value = {
}
def get_infix_binding_power_meta_value(terminal_id):
    try:
        return infix_binding_power_meta_value[terminal_id]
    except:
        return 0
def get_prefix_binding_power_meta_value(terminal_id):
    try:
        return prefix_binding_power_meta_value[terminal_id]
    except:
        return 0
def parse_meta_value(ctx):
    return parse_meta_value_internal(ctx, rbp=0)
def parse_meta_value_internal(ctx, rbp=0):
    left = nud_meta_value(ctx)
    if isinstance(left, ParseTree):
        left.isExpr = True
        left.isNud = True
    while ctx.tokens.current() and rbp < get_infix_binding_power_meta_value(ctx.tokens.current().id):
        left = led_meta_value(left, ctx)
    if left:
        left.isExpr = True
    return left
def nud_meta_value(ctx):
    tree = ParseTree(NonTerminal(106, 'meta_value'))
    current = ctx.tokens.current()
    ctx.nonterminal = "meta_value"
    if not current:
        return tree
    if current.id in rule_first[88]:
        # rule first == quote
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = $static_string
        ctx.rule = rules[88]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(parse_static_string(ctx))
    elif current.id in rule_first[89]:
        # rule first == boolean
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = :boolean
        ctx.rule = rules[89]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 20))
    elif current.id in rule_first[90]:
        # rule first == integer
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = :integer
        ctx.rule = rules[90]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 50))
    elif current.id in rule_first[91]:
        # rule first == float
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = :float
        ctx.rule = rules[91]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 45))
    elif current.id in rule_first[92]:
        # rule first == null
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = :null
        ctx.rule = rules[92]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 9))
    elif current.id in rule_first[94]:
        # rule first == lsquare
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = :lsquare $_gen20 :rsquare -> MetaArray( values=$1 )
        ctx.rule = rules[94]
        ast_parameters = OrderedDict([
            ('values', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('MetaArray', ast_parameters)
        tree.nudMorphemeCount = 3
        tree.add(expect(ctx, 43))
        tree.add(parse__gen20(ctx))
        tree.add(expect(ctx, 60))
    elif current.id in rule_first[96]:
        # rule first == lbrace
        # e first == boolean, lsquare, float, lbrace, meta_value, null, integer, quote
        # $meta_value = :lbrace $_gen21 :rbrace -> MetaObject( map=$1 )
        ctx.rule = rules[96]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('MetaObject', ast_parameters)
        tree.nudMorphemeCount = 3
        tree.add(expect(ctx, 52))
        tree.add(parse__gen21(ctx))
        tree.add(expect(ctx, 35))
    return tree
def led_meta_value(left, ctx):
    tree = ParseTree(NonTerminal(106, 'meta_value'))
    current = ctx.tokens.current()
    ctx.nonterminal = "meta_value"
    return tree
# END definitions for expression parser: meta_value
# START definitions for expression parser: type_e
infix_binding_power_type_e = {
    43: 1000, # $type_e = :type <=> :lsquare list($type_e, :comma) :rsquare -> Type( name=$0, subtype=$2 )
    46: 2000, # $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    10: 3000, # $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
}
prefix_binding_power_type_e = {
}
def get_infix_binding_power_type_e(terminal_id):
    try:
        return infix_binding_power_type_e[terminal_id]
    except:
        return 0
def get_prefix_binding_power_type_e(terminal_id):
    try:
        return prefix_binding_power_type_e[terminal_id]
    except:
        return 0
def parse_type_e(ctx):
    return parse_type_e_internal(ctx, rbp=0)
def parse_type_e_internal(ctx, rbp=0):
    left = nud_type_e(ctx)
    if isinstance(left, ParseTree):
        left.isExpr = True
        left.isNud = True
    while ctx.tokens.current() and rbp < get_infix_binding_power_type_e(ctx.tokens.current().id):
        left = led_type_e(left, ctx)
    if left:
        left.isExpr = True
    return left
def nud_type_e(ctx):
    tree = ParseTree(NonTerminal(93, 'type_e'))
    current = ctx.tokens.current()
    ctx.nonterminal = "type_e"
    if not current:
        return tree
    if current.id in rule_first[98]:
        # rule first == type
        # e first == type_e, identifier, type
        # $type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )
        ctx.rule = rules[98]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 42))
    elif current.id in rule_first[99]:
        # rule first == type
        # e first == type_e, identifier, type
        # $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
        ctx.rule = rules[99]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 42))
    elif current.id in rule_first[100]:
        # rule first == type
        # e first == type_e, identifier, type
        # $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
        ctx.rule = rules[100]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 42))
    elif current.id in rule_first[101]:
        # rule first == type
        # e first == type_e, identifier, type
        # $type_e = :type
        ctx.rule = rules[101]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 42))
    elif current.id in rule_first[102]:
        # rule first == identifier
        # e first == type_e, identifier, type
        # $type_e = :identifier
        ctx.rule = rules[102]
        tree.astTransform = AstTransformSubstitution(0)
        tree.nudMorphemeCount = 1
        tree.add(expect(ctx, 8))
    return tree
def led_type_e(left, ctx):
    tree = ParseTree(NonTerminal(93, 'type_e'))
    current = ctx.tokens.current()
    ctx.nonterminal = "type_e"
    if current.id == 43: # :lsquare
        # $type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )
        ctx.rule = rules[98]
        ast_parameters = OrderedDict([
            ('name', 0),
            ('subtype', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Type', ast_parameters)
        tree.add(left)
        tree.add(expect(ctx, 43)) # :lsquare
        tree.add(parse__gen22(ctx))
        tree.add(expect(ctx, 60)) # :rsquare
    if current.id == 46: # :qmark
        # $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
        ctx.rule = rules[99]
        ast_parameters = OrderedDict([
            ('innerType', 0),
        ])
        tree.astTransform = AstTransformNodeCreator('OptionalType', ast_parameters)
        tree.add(left)
        tree.add(expect(ctx, 46)) # :qmark
    if current.id == 10: # :plus
        # $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
        ctx.rule = rules[100]
        ast_parameters = OrderedDict([
            ('innerType', 0),
        ])
        tree.astTransform = AstTransformNodeCreator('NonEmptyType', ast_parameters)
        tree.add(left)
        tree.add(expect(ctx, 10)) # :plus
    return tree
# END definitions for expression parser: type_e
def parse__gen0(ctx):
    tree = ParseTree(NonTerminal(70, '_gen0'))
    tree.list = True
    ctx.nonterminal = "_gen0"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[70] and \
       ctx.tokens.current().id in nonterminal_follow[70]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(70)):
        tree.add(parse_import(ctx))
        ctx.nonterminal = "_gen0" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen1(ctx):
    tree = ParseTree(NonTerminal(130, '_gen1'))
    tree.list = True
    ctx.nonterminal = "_gen1"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[130] and \
       ctx.tokens.current().id in nonterminal_follow[130]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(130)):
        tree.add(parse_file_body_element(ctx))
        ctx.nonterminal = "_gen1" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen10(ctx):
    tree = ParseTree(NonTerminal(88, '_gen10'))
    tree.list = True
    ctx.nonterminal = "_gen10"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[88] and \
       ctx.tokens.current().id in nonterminal_follow[88]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(88)):
        tree.add(parse_input_declaration(ctx))
        ctx.nonterminal = "_gen10" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen11(ctx):
    tree = ParseTree(NonTerminal(105, '_gen11'))
    tree.list = True
    ctx.nonterminal = "_gen11"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[105] and \
       ctx.tokens.current().id in nonterminal_follow[105]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(105)):
        tree.add(parse_kv(ctx))
        ctx.nonterminal = "_gen11" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen12(ctx):
    tree = ParseTree(NonTerminal(108, '_gen12'))
    tree.list = True
    ctx.nonterminal = "_gen12"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[108] and \
       ctx.tokens.current().id in nonterminal_follow[108]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(108)):
        tree.add(parse_meta_kv(ctx))
        ctx.nonterminal = "_gen12" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen14(ctx):
    tree = ParseTree(NonTerminal(95, '_gen14'))
    tree.list = True
    ctx.nonterminal = "_gen14"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[95] and \
       ctx.tokens.current().id in nonterminal_follow[95]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(95)):
        tree.add(parse_output_kv(ctx))
        ctx.nonterminal = "_gen14" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen15(ctx):
    tree = ParseTree(NonTerminal(115, '_gen15'))
    tree.list = True
    ctx.nonterminal = "_gen15"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[115] and \
       ctx.tokens.current().id in nonterminal_follow[115]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(115)):
        tree.add(parse_wf_body_element(ctx))
        ctx.nonterminal = "_gen15" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen19(ctx):
    tree = ParseTree(NonTerminal(82, '_gen19'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen19"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[82] and \
       ctx.tokens.current().id in nonterminal_follow[82]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(82)):
        tree.add(parse_input_kv(ctx))
        ctx.nonterminal = "_gen19" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen2(ctx):
    tree = ParseTree(NonTerminal(98, '_gen2'))
    tree.list = True
    ctx.nonterminal = "_gen2"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[98] and \
       ctx.tokens.current().id in nonterminal_follow[98]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(98)):
        tree.add(parse_struct_declaration(ctx))
        ctx.nonterminal = "_gen2" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen20(ctx):
    tree = ParseTree(NonTerminal(124, '_gen20'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen20"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[124] and \
       ctx.tokens.current().id in nonterminal_follow[124]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(124)):
        tree.add(parse_meta_value(ctx))
        ctx.nonterminal = "_gen20" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen21(ctx):
    tree = ParseTree(NonTerminal(86, '_gen21'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen21"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[86] and \
       ctx.tokens.current().id in nonterminal_follow[86]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(86)):
        tree.add(parse_meta_kv(ctx))
        ctx.nonterminal = "_gen21" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen22(ctx):
    tree = ParseTree(NonTerminal(67, '_gen22'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen22"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[67] and \
       ctx.tokens.current().id in nonterminal_follow[67]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(67)):
        tree.add(parse_type_e(ctx))
        ctx.nonterminal = "_gen22" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen23(ctx):
    tree = ParseTree(NonTerminal(85, '_gen23'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen23"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[85] and \
       ctx.tokens.current().id in nonterminal_follow[85]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(85)):
        tree.add(parse_e(ctx))
        ctx.nonterminal = "_gen23" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen24(ctx):
    tree = ParseTree(NonTerminal(111, '_gen24'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen24"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[111] and \
       ctx.tokens.current().id in nonterminal_follow[111]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(111)):
        tree.add(parse_object_kv(ctx))
        ctx.nonterminal = "_gen24" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen25(ctx):
    tree = ParseTree(NonTerminal(89, '_gen25'))
    tree.list = True
    tree.list_separator_id = 57
    ctx.nonterminal = "_gen25"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[89] and \
       ctx.tokens.current().id in nonterminal_follow[89]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(89)):
        tree.add(parse_map_kv(ctx))
        ctx.nonterminal = "_gen25" # Horrible -- because parse_* can reset this
        if ctx.tokens.current() is not None and ctx.tokens.current().id == 57:
            tree.add(expect(ctx, 57));
        else:
          break
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen4(ctx):
    tree = ParseTree(NonTerminal(79, '_gen4'))
    tree.list = True
    ctx.nonterminal = "_gen4"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[79] and \
       ctx.tokens.current().id in nonterminal_follow[79]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(79)):
        tree.add(parse_string_piece(ctx))
        ctx.nonterminal = "_gen4" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen6(ctx):
    tree = ParseTree(NonTerminal(129, '_gen6'))
    tree.list = True
    ctx.nonterminal = "_gen6"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[129] and \
       ctx.tokens.current().id in nonterminal_follow[129]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(129)):
        tree.add(parse_import_alias(ctx))
        ctx.nonterminal = "_gen6" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen7(ctx):
    tree = ParseTree(NonTerminal(136, '_gen7'))
    tree.list = True
    ctx.nonterminal = "_gen7"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[136] and \
       ctx.tokens.current().id in nonterminal_follow[136]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(136)):
        tree.add(parse_task_sections(ctx))
        ctx.nonterminal = "_gen7" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen8(ctx):
    tree = ParseTree(NonTerminal(84, '_gen8'))
    tree.list = True
    ctx.nonterminal = "_gen8"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[84] and \
       ctx.tokens.current().id in nonterminal_follow[84]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(84)):
        tree.add(parse_command_part(ctx))
        ctx.nonterminal = "_gen8" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen9(ctx):
    tree = ParseTree(NonTerminal(123, '_gen9'))
    tree.list = True
    ctx.nonterminal = "_gen9"
    if ctx.tokens.current() is not None and \
       ctx.tokens.current().id not in nonterminal_first[123] and \
       ctx.tokens.current().id in nonterminal_follow[123]:
        return tree
    if ctx.tokens.current() is None:
        return tree
    minimum = 0
    while minimum > 0 or \
           (ctx.tokens.current() is not None and \
            ctx.tokens.current().id in nonterminal_first.get(123)):
        tree.add(parse_expression_placeholder_kv(ctx))
        ctx.nonterminal = "_gen9" # Horrible -- because parse_* can reset this
        minimum = max(minimum - 1, 0)
    return tree
def parse__gen13(ctx):
    current = ctx.tokens.current()
    rule = table[52][current.id] if current else -1
    tree = ParseTree(NonTerminal(117, '_gen13'))
    ctx.nonterminal = "_gen13"
    if current != None and current.id in nonterminal_follow[117] and current.id not in nonterminal_first[117]:
        return tree
    if current == None:
        return tree
    if rule == 50: # $_gen13 = $setter
        ctx.rule = rules[50]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_setter(ctx)
        tree.add(subtree)
        return tree
    return tree
def parse__gen16(ctx):
    current = ctx.tokens.current()
    rule = table[69][current.id] if current else -1
    tree = ParseTree(NonTerminal(134, '_gen16'))
    ctx.nonterminal = "_gen16"
    if current != None and current.id in nonterminal_follow[134] and current.id not in nonterminal_first[134]:
        return tree
    if current == None:
        return tree
    if rule == 70: # $_gen16 = $alias
        ctx.rule = rules[70]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_alias(ctx)
        tree.add(subtree)
        return tree
    return tree
def parse__gen17(ctx):
    current = ctx.tokens.current()
    rule = table[3][current.id] if current else -1
    tree = ParseTree(NonTerminal(68, '_gen17'))
    ctx.nonterminal = "_gen17"
    if current != None and current.id in nonterminal_follow[68] and current.id not in nonterminal_first[68]:
        return tree
    if current == None:
        return tree
    if rule == 72: # $_gen17 = $call_brace_block
        ctx.rule = rules[72]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_call_brace_block(ctx)
        tree.add(subtree)
        return tree
    return tree
def parse__gen18(ctx):
    current = ctx.tokens.current()
    rule = table[16][current.id] if current else -1
    tree = ParseTree(NonTerminal(81, '_gen18'))
    ctx.nonterminal = "_gen18"
    if current != None and current.id in nonterminal_follow[81] and current.id not in nonterminal_first[81]:
        return tree
    if current == None:
        return tree
    if rule == 75: # $_gen18 = $call_body
        ctx.rule = rules[75]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_call_body(ctx)
        tree.add(subtree)
        return tree
    return tree
def parse__gen3(ctx):
    current = ctx.tokens.current()
    rule = table[47][current.id] if current else -1
    tree = ParseTree(NonTerminal(112, '_gen3'))
    ctx.nonterminal = "_gen3"
    if current != None and current.id in nonterminal_follow[112] and current.id not in nonterminal_first[112]:
        return tree
    if current == None:
        return tree
    if rule == 10: # $_gen3 = :string
        ctx.rule = rules[10]
        tree.astTransform = AstTransformSubstitution(0)
        t = expect(ctx, 58) # :string
        tree.add(t)
        return tree
    return tree
def parse__gen5(ctx):
    current = ctx.tokens.current()
    rule = table[11][current.id] if current else -1
    tree = ParseTree(NonTerminal(76, '_gen5'))
    ctx.nonterminal = "_gen5"
    if current != None and current.id in nonterminal_follow[76] and current.id not in nonterminal_first[76]:
        return tree
    if current == None:
        return tree
    if rule == 17: # $_gen5 = $import_namespace
        ctx.rule = rules[17]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_import_namespace(ctx)
        tree.add(subtree)
        return tree
    return tree
def parse_alias(ctx):
    current = ctx.tokens.current()
    rule = table[56][current.id] if current else -1
    tree = ParseTree(NonTerminal(121, 'alias'))
    ctx.nonterminal = "alias"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 80: # $alias = :as :identifier -> $1
        ctx.rule = rules[80]
        tree.astTransform = AstTransformSubstitution(1)
        t = expect(ctx, 28) # :as
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[121] if x >=0],
      rules[80]
    )
def parse_call(ctx):
    current = ctx.tokens.current()
    rule = table[13][current.id] if current else -1
    tree = ParseTree(NonTerminal(78, 'call'))
    ctx.nonterminal = "call"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 74: # $call = :call :fqn $_gen16 $_gen17 -> Call( task=$1, alias=$2, body=$3 )
        ctx.rule = rules[74]
        ast_parameters = OrderedDict([
            ('task', 1),
            ('alias', 2),
            ('body', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('Call', ast_parameters)
        t = expect(ctx, 21) # :call
        tree.add(t)
        t = expect(ctx, 27) # :fqn
        tree.add(t)
        subtree = parse__gen16(ctx)
        tree.add(subtree)
        subtree = parse__gen17(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[78] if x >=0],
      rules[74]
    )
def parse_call_body(ctx):
    current = ctx.tokens.current()
    rule = table[9][current.id] if current else -1
    tree = ParseTree(NonTerminal(74, 'call_body'))
    ctx.nonterminal = "call_body"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 79: # $call_body = :input :colon $_gen19 -> CallBody( inputs=$2 )
        ctx.rule = rules[79]
        ast_parameters = OrderedDict([
            ('inputs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('CallBody', ast_parameters)
        t = expect(ctx, 29) # :input
        tree.add(t)
        t = expect(ctx, 4) # :colon
        tree.add(t)
        subtree = parse__gen19(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[74] if x >=0],
      rules[79]
    )
def parse_call_brace_block(ctx):
    current = ctx.tokens.current()
    rule = table[1][current.id] if current else -1
    tree = ParseTree(NonTerminal(66, 'call_brace_block'))
    ctx.nonterminal = "call_brace_block"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 77: # $call_brace_block = :lbrace $_gen18 :rbrace -> $1
        ctx.rule = rules[77]
        tree.astTransform = AstTransformSubstitution(1)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen18(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[66] if x >=0],
      rules[77]
    )
def parse_command(ctx):
    current = ctx.tokens.current()
    rule = table[29][current.id] if current else -1
    tree = ParseTree(NonTerminal(94, 'command'))
    ctx.nonterminal = "command"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 33: # $command = :raw_command :raw_cmd_start $_gen8 :raw_cmd_end -> RawCommand( parts=$2 )
        ctx.rule = rules[33]
        ast_parameters = OrderedDict([
            ('parts', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('RawCommand', ast_parameters)
        t = expect(ctx, 47) # :raw_command
        tree.add(t)
        t = expect(ctx, 23) # :raw_cmd_start
        tree.add(t)
        subtree = parse__gen8(ctx)
        tree.add(subtree)
        t = expect(ctx, 51) # :raw_cmd_end
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[94] if x >=0],
      rules[33]
    )
def parse_command_part(ctx):
    current = ctx.tokens.current()
    rule = table[66][current.id] if current else -1
    tree = ParseTree(NonTerminal(131, 'command_part'))
    ctx.nonterminal = "command_part"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 34: # $command_part = :cmd_part
        ctx.rule = rules[34]
        tree.astTransform = AstTransformSubstitution(0)
        t = expect(ctx, 55) # :cmd_part
        tree.add(t)
        return tree
    elif rule == 35: # $command_part = $expression_placeholder
        ctx.rule = rules[35]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_expression_placeholder(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[131] if x >=0],
      rules[35]
    )
def parse_declaration(ctx):
    current = ctx.tokens.current()
    rule = table[15][current.id] if current else -1
    tree = ParseTree(NonTerminal(80, 'declaration'))
    ctx.nonterminal = "declaration"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 53: # $declaration = $type_e :identifier $setter -> Declaration( type=$0, name=$1, expression=$2 )
        ctx.rule = rules[53]
        ast_parameters = OrderedDict([
            ('type', 0),
            ('name', 1),
            ('expression', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Declaration', ast_parameters)
        subtree = parse_type_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        subtree = parse_setter(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[80] if x >=0],
      rules[53]
    )
def parse_document(ctx):
    current = ctx.tokens.current()
    rule = table[70][current.id] if current else -1
    tree = ParseTree(NonTerminal(135, 'document'))
    ctx.nonterminal = "document"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 2: # $document = $version $_gen0 $_gen1 -> Draft3File( version=$0, imports=$1, body=$2 )
        ctx.rule = rules[2]
        ast_parameters = OrderedDict([
            ('version', 0),
            ('imports', 1),
            ('body', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Draft3File', ast_parameters)
        subtree = parse_version(ctx)
        tree.add(subtree)
        subtree = parse__gen0(ctx)
        tree.add(subtree)
        subtree = parse__gen1(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[135] if x >=0],
      rules[2]
    )
def parse_expression_placeholder(ctx):
    current = ctx.tokens.current()
    rule = table[54][current.id] if current else -1
    tree = ParseTree(NonTerminal(119, 'expression_placeholder'))
    ctx.nonterminal = "expression_placeholder"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 37: # $expression_placeholder = :expression_placeholder_start $_gen9 $e :expression_placeholder_end -> ExpressionPlaceholder( attributes=$1, expr=$2 )
        ctx.rule = rules[37]
        ast_parameters = OrderedDict([
            ('attributes', 1),
            ('expr', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('ExpressionPlaceholder', ast_parameters)
        t = expect(ctx, 49) # :expression_placeholder_start
        tree.add(t)
        subtree = parse__gen9(ctx)
        tree.add(subtree)
        subtree = parse_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 36) # :expression_placeholder_end
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[119] if x >=0],
      rules[37]
    )
def parse_expression_placeholder_kv(ctx):
    current = ctx.tokens.current()
    rule = table[12][current.id] if current else -1
    tree = ParseTree(NonTerminal(77, 'expression_placeholder_kv'))
    ctx.nonterminal = "expression_placeholder_kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 38: # $expression_placeholder_kv = :cmd_attr_hint :identifier :equal $e -> ExpressionPlaceholderAttr( key=$1, value=$3 )
        ctx.rule = rules[38]
        ast_parameters = OrderedDict([
            ('key', 1),
            ('value', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('ExpressionPlaceholderAttr', ast_parameters)
        t = expect(ctx, 11) # :cmd_attr_hint
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 53) # :equal
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[77] if x >=0],
      rules[38]
    )
def parse_file_body_element(ctx):
    current = ctx.tokens.current()
    rule = table[39][current.id] if current else -1
    tree = ParseTree(NonTerminal(104, 'file_body_element'))
    ctx.nonterminal = "file_body_element"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 3: # $file_body_element = $workflow
        ctx.rule = rules[3]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_workflow(ctx)
        tree.add(subtree)
        return tree
    elif rule == 4: # $file_body_element = $task
        ctx.rule = rules[4]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_task(ctx)
        tree.add(subtree)
        return tree
    elif rule == 5: # $file_body_element = $struct
        ctx.rule = rules[5]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_struct(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[104] if x >=0],
      rules[5]
    )
def parse_if_stmt(ctx):
    current = ctx.tokens.current()
    rule = table[0][current.id] if current else -1
    tree = ParseTree(NonTerminal(65, 'if_stmt'))
    ctx.nonterminal = "if_stmt"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 84: # $if_stmt = :if :lparen $e :rparen :lbrace $_gen15 :rbrace -> If( expression=$2, body=$5 )
        ctx.rule = rules[84]
        ast_parameters = OrderedDict([
            ('expression', 2),
            ('body', 5),
        ])
        tree.astTransform = AstTransformNodeCreator('If', ast_parameters)
        t = expect(ctx, 12) # :if
        tree.add(t)
        t = expect(ctx, 5) # :lparen
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 37) # :rparen
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen15(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[65] if x >=0],
      rules[84]
    )
def parse_import(ctx):
    current = ctx.tokens.current()
    rule = table[44][current.id] if current else -1
    tree = ParseTree(NonTerminal(109, 'import'))
    ctx.nonterminal = "import"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 20: # $import = :import $static_string $_gen5 $_gen6 -> Import( uri=$1, namespace=$2, aliases=$3 )
        ctx.rule = rules[20]
        ast_parameters = OrderedDict([
            ('uri', 1),
            ('namespace', 2),
            ('aliases', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('Import', ast_parameters)
        t = expect(ctx, 25) # :import
        tree.add(t)
        subtree = parse_static_string(ctx)
        tree.add(subtree)
        subtree = parse__gen5(ctx)
        tree.add(subtree)
        subtree = parse__gen6(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[109] if x >=0],
      rules[20]
    )
def parse_import_alias(ctx):
    current = ctx.tokens.current()
    rule = table[60][current.id] if current else -1
    tree = ParseTree(NonTerminal(125, 'import_alias'))
    ctx.nonterminal = "import_alias"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 22: # $import_alias = :alias :identifier :as :identifier -> ImportAlias( old_name=$1, new_name=$3 )
        ctx.rule = rules[22]
        ast_parameters = OrderedDict([
            ('old_name', 1),
            ('new_name', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('ImportAlias', ast_parameters)
        t = expect(ctx, 33) # :alias
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 28) # :as
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[125] if x >=0],
      rules[22]
    )
def parse_import_namespace(ctx):
    current = ctx.tokens.current()
    rule = table[10][current.id] if current else -1
    tree = ParseTree(NonTerminal(75, 'import_namespace'))
    ctx.nonterminal = "import_namespace"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 21: # $import_namespace = :as :identifier -> $1
        ctx.rule = rules[21]
        tree.astTransform = AstTransformSubstitution(1)
        t = expect(ctx, 28) # :as
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[75] if x >=0],
      rules[21]
    )
def parse_input_declaration(ctx):
    current = ctx.tokens.current()
    rule = table[42][current.id] if current else -1
    tree = ParseTree(NonTerminal(107, 'input_declaration'))
    ctx.nonterminal = "input_declaration"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 52: # $input_declaration = $type_e :identifier $_gen13 -> InputDeclaration( type=$0, name=$1, expression=$2 )
        ctx.rule = rules[52]
        ast_parameters = OrderedDict([
            ('type', 0),
            ('name', 1),
            ('expression', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('InputDeclaration', ast_parameters)
        subtree = parse_type_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        subtree = parse__gen13(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[107] if x >=0],
      rules[52]
    )
def parse_input_kv(ctx):
    current = ctx.tokens.current()
    rule = table[31][current.id] if current else -1
    tree = ParseTree(NonTerminal(96, 'input_kv'))
    ctx.nonterminal = "input_kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 87: # $input_kv = :identifier :equal $e -> ObjectKV( key=$0, value=$2 )
        ctx.rule = rules[87]
        ast_parameters = OrderedDict([
            ('key', 0),
            ('value', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('ObjectKV', ast_parameters)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 53) # :equal
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[96] if x >=0],
      rules[87]
    )
def parse_inputs(ctx):
    current = ctx.tokens.current()
    rule = table[32][current.id] if current else -1
    tree = ParseTree(NonTerminal(97, 'inputs'))
    ctx.nonterminal = "inputs"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 40: # $inputs = :input :lbrace $_gen10 :rbrace -> Inputs( inputs=$2 )
        ctx.rule = rules[40]
        ast_parameters = OrderedDict([
            ('inputs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Inputs', ast_parameters)
        t = expect(ctx, 29) # :input
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen10(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[97] if x >=0],
      rules[40]
    )
def parse_kv(ctx):
    current = ctx.tokens.current()
    rule = table[45][current.id] if current else -1
    tree = ParseTree(NonTerminal(110, 'kv'))
    ctx.nonterminal = "kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 44: # $kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )
        ctx.rule = rules[44]
        ast_parameters = OrderedDict([
            ('key', 0),
            ('value', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('RuntimeAttribute', ast_parameters)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 4) # :colon
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[110] if x >=0],
      rules[44]
    )
def parse_map_kv(ctx):
    current = ctx.tokens.current()
    rule = table[51][current.id] if current else -1
    tree = ParseTree(NonTerminal(116, 'map_kv'))
    ctx.nonterminal = "map_kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 55: # $map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )
        ctx.rule = rules[55]
        ast_parameters = OrderedDict([
            ('key', 0),
            ('value', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('MapLiteralKv', ast_parameters)
        subtree = parse_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 4) # :colon
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[116] if x >=0],
      rules[55]
    )
def parse_meta(ctx):
    current = ctx.tokens.current()
    rule = table[49][current.id] if current else -1
    tree = ParseTree(NonTerminal(114, 'meta'))
    ctx.nonterminal = "meta"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 45: # $meta = :meta $meta_map -> Meta( map=$1 )
        ctx.rule = rules[45]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('Meta', ast_parameters)
        t = expect(ctx, 54) # :meta
        tree.add(t)
        subtree = parse_meta_map(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[114] if x >=0],
      rules[45]
    )
def parse_meta_kv(ctx):
    current = ctx.tokens.current()
    rule = table[37][current.id] if current else -1
    tree = ParseTree(NonTerminal(102, 'meta_kv'))
    ctx.nonterminal = "meta_kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 49: # $meta_kv = :identifier :colon $meta_value -> MetaKvPair( key=$0, value=$2 )
        ctx.rule = rules[49]
        ast_parameters = OrderedDict([
            ('key', 0),
            ('value', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('MetaKvPair', ast_parameters)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 4) # :colon
        tree.add(t)
        subtree = parse_meta_value(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[102] if x >=0],
      rules[49]
    )
def parse_meta_map(ctx):
    current = ctx.tokens.current()
    rule = table[35][current.id] if current else -1
    tree = ParseTree(NonTerminal(100, 'meta_map'))
    ctx.nonterminal = "meta_map"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 48: # $meta_map = :lbrace $_gen12 :rbrace -> $1
        ctx.rule = rules[48]
        tree.astTransform = AstTransformSubstitution(1)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen12(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[100] if x >=0],
      rules[48]
    )
def parse_object_kv(ctx):
    current = ctx.tokens.current()
    rule = table[38][current.id] if current else -1
    tree = ParseTree(NonTerminal(103, 'object_kv'))
    ctx.nonterminal = "object_kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 86: # $object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )
        ctx.rule = rules[86]
        ast_parameters = OrderedDict([
            ('key', 0),
            ('value', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('ObjectKV', ast_parameters)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 4) # :colon
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[103] if x >=0],
      rules[86]
    )
def parse_output_kv(ctx):
    current = ctx.tokens.current()
    rule = table[36][current.id] if current else -1
    tree = ParseTree(NonTerminal(101, 'output_kv'))
    ctx.nonterminal = "output_kv"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 58: # $output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )
        ctx.rule = rules[58]
        ast_parameters = OrderedDict([
            ('type', 0),
            ('name', 1),
            ('expression', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('Output', ast_parameters)
        subtree = parse_type_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 53) # :equal
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[101] if x >=0],
      rules[58]
    )
def parse_outputs(ctx):
    current = ctx.tokens.current()
    rule = table[62][current.id] if current else -1
    tree = ParseTree(NonTerminal(127, 'outputs'))
    ctx.nonterminal = "outputs"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 57: # $outputs = :output :lbrace $_gen14 :rbrace -> Outputs( outputs=$2 )
        ctx.rule = rules[57]
        ast_parameters = OrderedDict([
            ('outputs', 2),
        ])
        tree.astTransform = AstTransformNodeCreator('Outputs', ast_parameters)
        t = expect(ctx, 26) # :output
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen14(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[127] if x >=0],
      rules[57]
    )
def parse_parameter_meta(ctx):
    current = ctx.tokens.current()
    rule = table[8][current.id] if current else -1
    tree = ParseTree(NonTerminal(73, 'parameter_meta'))
    ctx.nonterminal = "parameter_meta"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 46: # $parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )
        ctx.rule = rules[46]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('ParameterMeta', ast_parameters)
        t = expect(ctx, 41) # :parameter_meta
        tree.add(t)
        subtree = parse_meta_map(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[73] if x >=0],
      rules[46]
    )
def parse_rt_map(ctx):
    current = ctx.tokens.current()
    rule = table[34][current.id] if current else -1
    tree = ParseTree(NonTerminal(99, 'rt_map'))
    ctx.nonterminal = "rt_map"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 43: # $rt_map = :lbrace $_gen11 :rbrace -> $1
        ctx.rule = rules[43]
        tree.astTransform = AstTransformSubstitution(1)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen11(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[99] if x >=0],
      rules[43]
    )
def parse_runtime(ctx):
    current = ctx.tokens.current()
    rule = table[63][current.id] if current else -1
    tree = ParseTree(NonTerminal(128, 'runtime'))
    ctx.nonterminal = "runtime"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 41: # $runtime = :runtime $rt_map -> Runtime( map=$1 )
        ctx.rule = rules[41]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('Runtime', ast_parameters)
        t = expect(ctx, 30) # :runtime
        tree.add(t)
        subtree = parse_rt_map(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[128] if x >=0],
      rules[41]
    )
def parse_scatter(ctx):
    current = ctx.tokens.current()
    rule = table[67][current.id] if current else -1
    tree = ParseTree(NonTerminal(132, 'scatter'))
    ctx.nonterminal = "scatter"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 85: # $scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen15 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )
        ctx.rule = rules[85]
        ast_parameters = OrderedDict([
            ('item', 2),
            ('collection', 4),
            ('body', 7),
        ])
        tree.astTransform = AstTransformNodeCreator('Scatter', ast_parameters)
        t = expect(ctx, 64) # :scatter
        tree.add(t)
        t = expect(ctx, 5) # :lparen
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 3) # :in
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 37) # :rparen
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen15(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[132] if x >=0],
      rules[85]
    )
def parse_setter(ctx):
    current = ctx.tokens.current()
    rule = table[72][current.id] if current else -1
    tree = ParseTree(NonTerminal(137, 'setter'))
    ctx.nonterminal = "setter"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 54: # $setter = :equal $e -> $1
        ctx.rule = rules[54]
        tree.astTransform = AstTransformSubstitution(1)
        t = expect(ctx, 53) # :equal
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[137] if x >=0],
      rules[54]
    )
def parse_static_string(ctx):
    current = ctx.tokens.current()
    rule = table[7][current.id] if current else -1
    tree = ParseTree(NonTerminal(72, 'static_string'))
    ctx.nonterminal = "static_string"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 12: # $static_string = :quote $_gen3 :quote -> StaticString( value=$1 )
        ctx.rule = rules[12]
        ast_parameters = OrderedDict([
            ('value', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('StaticString', ast_parameters)
        t = expect(ctx, 17) # :quote
        tree.add(t)
        subtree = parse__gen3(ctx)
        tree.add(subtree)
        t = expect(ctx, 17) # :quote
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[72] if x >=0],
      rules[12]
    )
def parse_string_literal(ctx):
    current = ctx.tokens.current()
    rule = table[22][current.id] if current else -1
    tree = ParseTree(NonTerminal(87, 'string_literal'))
    ctx.nonterminal = "string_literal"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 14: # $string_literal = :quote $_gen4 :quote -> StringLiteral( pieces=$1 )
        ctx.rule = rules[14]
        ast_parameters = OrderedDict([
            ('pieces', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('StringLiteral', ast_parameters)
        t = expect(ctx, 17) # :quote
        tree.add(t)
        subtree = parse__gen4(ctx)
        tree.add(subtree)
        t = expect(ctx, 17) # :quote
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[87] if x >=0],
      rules[14]
    )
def parse_string_piece(ctx):
    current = ctx.tokens.current()
    rule = table[61][current.id] if current else -1
    tree = ParseTree(NonTerminal(126, 'string_piece'))
    ctx.nonterminal = "string_piece"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 15: # $string_piece = :string
        ctx.rule = rules[15]
        tree.astTransform = AstTransformSubstitution(0)
        t = expect(ctx, 58) # :string
        tree.add(t)
        return tree
    elif rule == 16: # $string_piece = $expression_placeholder
        ctx.rule = rules[16]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_expression_placeholder(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[126] if x >=0],
      rules[16]
    )
def parse_struct(ctx):
    current = ctx.tokens.current()
    rule = table[26][current.id] if current else -1
    tree = ParseTree(NonTerminal(91, 'struct'))
    ctx.nonterminal = "struct"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 8: # $struct = :struct :identifier :lbrace $_gen2 :rbrace -> Struct( name=$1, entries=$3 )
        ctx.rule = rules[8]
        ast_parameters = OrderedDict([
            ('name', 1),
            ('entries', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('Struct', ast_parameters)
        t = expect(ctx, 32) # :struct
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen2(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[91] if x >=0],
      rules[8]
    )
def parse_struct_declaration(ctx):
    current = ctx.tokens.current()
    rule = table[6][current.id] if current else -1
    tree = ParseTree(NonTerminal(71, 'struct_declaration'))
    ctx.nonterminal = "struct_declaration"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 9: # $struct_declaration = $type_e :identifier -> StructEntry( type=$0, name=$1 )
        ctx.rule = rules[9]
        ast_parameters = OrderedDict([
            ('type', 0),
            ('name', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('StructEntry', ast_parameters)
        subtree = parse_type_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[71] if x >=0],
      rules[9]
    )
def parse_task(ctx):
    current = ctx.tokens.current()
    rule = table[18][current.id] if current else -1
    tree = ParseTree(NonTerminal(83, 'task'))
    ctx.nonterminal = "task"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 24: # $task = :task :identifier :lbrace $_gen7 :rbrace -> Task( name=$1, sections=$3 )
        ctx.rule = rules[24]
        ast_parameters = OrderedDict([
            ('name', 1),
            ('sections', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('Task', ast_parameters)
        t = expect(ctx, 48) # :task
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen7(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[83] if x >=0],
      rules[24]
    )
def parse_task_sections(ctx):
    current = ctx.tokens.current()
    rule = table[48][current.id] if current else -1
    tree = ParseTree(NonTerminal(113, 'task_sections'))
    ctx.nonterminal = "task_sections"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 25: # $task_sections = $command
        ctx.rule = rules[25]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_command(ctx)
        tree.add(subtree)
        return tree
    elif rule == 26: # $task_sections = $inputs
        ctx.rule = rules[26]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_inputs(ctx)
        tree.add(subtree)
        return tree
    elif rule == 27: # $task_sections = $outputs
        ctx.rule = rules[27]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_outputs(ctx)
        tree.add(subtree)
        return tree
    elif rule == 28: # $task_sections = $runtime
        ctx.rule = rules[28]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_runtime(ctx)
        tree.add(subtree)
        return tree
    elif rule == 29: # $task_sections = $parameter_meta
        ctx.rule = rules[29]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_parameter_meta(ctx)
        tree.add(subtree)
        return tree
    elif rule == 30: # $task_sections = $meta
        ctx.rule = rules[30]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_meta(ctx)
        tree.add(subtree)
        return tree
    elif rule == 31: # $task_sections = $declaration
        ctx.rule = rules[31]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_declaration(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[113] if x >=0],
      rules[31]
    )
def parse_version(ctx):
    current = ctx.tokens.current()
    rule = table[57][current.id] if current else -1
    tree = ParseTree(NonTerminal(122, 'version'))
    ctx.nonterminal = "version"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 6: # $version = :version :version_name -> VersionDeclaration( v=$1 )
        ctx.rule = rules[6]
        ast_parameters = OrderedDict([
            ('v', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('VersionDeclaration', ast_parameters)
        t = expect(ctx, 44) # :version
        tree.add(t)
        t = expect(ctx, 14) # :version_name
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[122] if x >=0],
      rules[6]
    )
def parse_wf_body_element(ctx):
    current = ctx.tokens.current()
    rule = table[53][current.id] if current else -1
    tree = ParseTree(NonTerminal(118, 'wf_body_element'))
    ctx.nonterminal = "wf_body_element"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 61: # $wf_body_element = $call
        ctx.rule = rules[61]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_call(ctx)
        tree.add(subtree)
        return tree
    elif rule == 62: # $wf_body_element = $declaration
        ctx.rule = rules[62]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_declaration(ctx)
        tree.add(subtree)
        return tree
    elif rule == 63: # $wf_body_element = $while_loop
        ctx.rule = rules[63]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_while_loop(ctx)
        tree.add(subtree)
        return tree
    elif rule == 64: # $wf_body_element = $if_stmt
        ctx.rule = rules[64]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_if_stmt(ctx)
        tree.add(subtree)
        return tree
    elif rule == 65: # $wf_body_element = $scatter
        ctx.rule = rules[65]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_scatter(ctx)
        tree.add(subtree)
        return tree
    elif rule == 66: # $wf_body_element = $inputs
        ctx.rule = rules[66]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_inputs(ctx)
        tree.add(subtree)
        return tree
    elif rule == 67: # $wf_body_element = $outputs
        ctx.rule = rules[67]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_outputs(ctx)
        tree.add(subtree)
        return tree
    elif rule == 68: # $wf_body_element = $wf_parameter_meta
        ctx.rule = rules[68]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_wf_parameter_meta(ctx)
        tree.add(subtree)
        return tree
    elif rule == 69: # $wf_body_element = $wf_meta
        ctx.rule = rules[69]
        tree.astTransform = AstTransformSubstitution(0)
        subtree = parse_wf_meta(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[118] if x >=0],
      rules[69]
    )
def parse_wf_meta(ctx):
    current = ctx.tokens.current()
    rule = table[25][current.id] if current else -1
    tree = ParseTree(NonTerminal(90, 'wf_meta'))
    ctx.nonterminal = "wf_meta"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 82: # $wf_meta = :meta $meta_map -> Meta( map=$1 )
        ctx.rule = rules[82]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('Meta', ast_parameters)
        t = expect(ctx, 54) # :meta
        tree.add(t)
        subtree = parse_meta_map(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[90] if x >=0],
      rules[82]
    )
def parse_wf_parameter_meta(ctx):
    current = ctx.tokens.current()
    rule = table[68][current.id] if current else -1
    tree = ParseTree(NonTerminal(133, 'wf_parameter_meta'))
    ctx.nonterminal = "wf_parameter_meta"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 81: # $wf_parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )
        ctx.rule = rules[81]
        ast_parameters = OrderedDict([
            ('map', 1),
        ])
        tree.astTransform = AstTransformNodeCreator('ParameterMeta', ast_parameters)
        t = expect(ctx, 41) # :parameter_meta
        tree.add(t)
        subtree = parse_meta_map(ctx)
        tree.add(subtree)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[133] if x >=0],
      rules[81]
    )
def parse_while_loop(ctx):
    current = ctx.tokens.current()
    rule = table[27][current.id] if current else -1
    tree = ParseTree(NonTerminal(92, 'while_loop'))
    ctx.nonterminal = "while_loop"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 83: # $while_loop = :while :lparen $e :rparen :lbrace $_gen15 :rbrace -> WhileLoop( expression=$2, body=$5 )
        ctx.rule = rules[83]
        ast_parameters = OrderedDict([
            ('expression', 2),
            ('body', 5),
        ])
        tree.astTransform = AstTransformNodeCreator('WhileLoop', ast_parameters)
        t = expect(ctx, 31) # :while
        tree.add(t)
        t = expect(ctx, 5) # :lparen
        tree.add(t)
        subtree = parse_e(ctx)
        tree.add(subtree)
        t = expect(ctx, 37) # :rparen
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen15(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[92] if x >=0],
      rules[83]
    )
def parse_workflow(ctx):
    current = ctx.tokens.current()
    rule = table[4][current.id] if current else -1
    tree = ParseTree(NonTerminal(69, 'workflow'))
    ctx.nonterminal = "workflow"
    if current == None:
        raise ctx.errors.unexpected_eof()
    if rule == 60: # $workflow = :workflow :identifier :lbrace $_gen15 :rbrace -> Workflow( name=$1, body=$3 )
        ctx.rule = rules[60]
        ast_parameters = OrderedDict([
            ('name', 1),
            ('body', 3),
        ])
        tree.astTransform = AstTransformNodeCreator('Workflow', ast_parameters)
        t = expect(ctx, 19) # :workflow
        tree.add(t)
        t = expect(ctx, 8) # :identifier
        tree.add(t)
        t = expect(ctx, 52) # :lbrace
        tree.add(t)
        subtree = parse__gen15(ctx)
        tree.add(subtree)
        t = expect(ctx, 35) # :rbrace
        tree.add(t)
        return tree
    raise ctx.errors.unexpected_symbol(
      ctx.nonterminal,
      ctx.tokens.current(),
      [terminals[x] for x in nonterminal_first[69] if x >=0],
      rules[60]
    )
# Lexer Code #
# START USER CODE
def init():
    return {
        'context': None,
        'replacements': {
            re.compile(r"\\n"): 0x000A,
            re.compile(r"\\r"): 0x000D,
            re.compile(r"\\b"): 0x0008,
            re.compile(r"\\t"): 0x0009,
            re.compile(r"\\a"): 0x0007,
            re.compile(r"\\v"): 0x000B,
            re.compile(r'\\"'): 0x0022,
            re.compile(r"\\'"): 0x0027,
            re.compile(r"\\\?"): 0x003F
        },
        'escapes': {
            re.compile(r'(\\([0-7]{1,3}))'): 8,
            re.compile(r'(\\[xX]([0-9a-fA-F]{1,4}))'): 16,
            re.compile(r'(\\[uU]([0-9a-fA-F]{4}))'): 16
        }
    }
def workflow(ctx, terminal, source_string, line, col):
    ctx.user_context['context'] = 'workflow'
    default_action(ctx, terminal, source_string, line, col)
def task(ctx, terminal, source_string, line, col):
    ctx.user_context['context'] = 'task'
    default_action(ctx, terminal, source_string, line, col)
def output(ctx, terminal, source_string, line, col):
    if ctx.user_context['context'] == 'workflow':
        ctx.stack.append('wf_output')
    default_action(ctx, terminal, source_string, line, col)
def wdl_unescape(ctx, terminal, source_string, line, col):
    for regex, c in ctx.user_context['replacements'].items():
        source_string = regex.sub(chr(c), source_string)
    source_string = source_string.replace("\u005C\u005C", "\u005C")
    for regex, base in ctx.user_context['escapes'].items():
        for escape_sequence, number in regex.findall(source_string):
            source_string = source_string.replace(escape_sequence, chr(int(number, base)))
    default_action(ctx, terminal, source_string, line, col)
# END USER CODE
def emit(ctx, terminal, source_string, line, col):
    if terminal:
        ctx.tokens.append(Terminal(terminals[terminal], terminal, source_string, ctx.resource, line, col))
def default_action(ctx, terminal, source_string, line, col):
    emit(ctx, terminal, source_string, line, col)
def post_filter(tokens):
    return tokens
def destroy(context):
    pass
class LexerStackPush:
    def __init__(self, mode):
        self.mode = mode
class LexerAction:
    def __init__(self, action):
        self.action = action
class LexerContext:
    def __init__(self, string, resource, errors, user_context):
        self.__dict__.update(locals())
        self.stack = ['default']
        self.line = 1
        self.col = 1
        self.tokens = []
        self.user_context = user_context
        self.re_match = None # https://docs.python.org/3/library/re.html#match-objects
class HermesLexer:
    regex = {
        'default': OrderedDict([
          (re.compile(r'#.*'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'\s+'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'^version(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('version', 0, None),
              LexerStackPush('awaiting_version_name'),
          ]),
        ]),
        'main': OrderedDict([
          (re.compile(r'\s+'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'/\*(.*?)\*/', re.DOTALL), [
              # (terminal, group, function)
          ]),
          (re.compile(r'#.*'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'task(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('task', 0, task),
          ]),
          (re.compile(r'(call)\s+'), [
              # (terminal, group, function)
              ('call', 1, None),
              LexerStackPush('task_fqn'),
          ]),
          (re.compile(r'workflow(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('workflow', 0, workflow),
          ]),
          (re.compile(r'struct(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('struct', 0, None),
          ]),
          (re.compile(r'import(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('import', 0, None),
          ]),
          (re.compile(r'alias(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('alias', 0, None),
          ]),
          (re.compile(r'input(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('input', 0, None),
          ]),
          (re.compile(r'output(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('output', 0, None),
          ]),
          (re.compile(r'as(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('as', 0, None),
          ]),
          (re.compile(r'if(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('if', 0, None),
          ]),
          (re.compile(r'then(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('then', 0, None),
          ]),
          (re.compile(r'else(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('else', 0, None),
          ]),
          (re.compile(r'runtime(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('runtime', 0, None),
          ]),
          (re.compile(r'scatter(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('scatter', 0, None),
              LexerStackPush('scatter'),
          ]),
          (re.compile(r'command\s*(?=<<<)'), [
              # (terminal, group, function)
              ('raw_command', 0, None),
              LexerStackPush('raw_command2'),
          ]),
          (re.compile(r'command\s*(?=\{)'), [
              # (terminal, group, function)
              ('raw_command', 0, None),
              LexerStackPush('raw_command'),
          ]),
          (re.compile(r'parameter_meta(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('parameter_meta', 0, None),
          ]),
          (re.compile(r'meta(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('meta', 0, None),
          ]),
          (re.compile(r'(true|false)(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('boolean', 0, None),
          ]),
          (re.compile(r'(object)\s*(\{)'), [
              # (terminal, group, function)
              ('object', 0, None),
              ('lbrace', 0, None),
          ]),
          (re.compile(r'(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('type', 0, None),
          ]),
          (re.compile(r'[a-zA-Z]([a-zA-Z0-9_])*'), [
              # (terminal, group, function)
              ('identifier', 0, None),
          ]),
          (re.compile(r'null'), [
              # (terminal, group, function)
              ('null', 0, None),
          ]),
          (re.compile(r':'), [
              # (terminal, group, function)
              ('colon', 0, None),
          ]),
          (re.compile(r','), [
              # (terminal, group, function)
              ('comma', 0, None),
          ]),
          (re.compile(r'=='), [
              # (terminal, group, function)
              ('double_equal', 0, None),
          ]),
          (re.compile(r'\|\|'), [
              # (terminal, group, function)
              ('double_pipe', 0, None),
          ]),
          (re.compile(r'\&\&'), [
              # (terminal, group, function)
              ('double_ampersand', 0, None),
          ]),
          (re.compile(r'!='), [
              # (terminal, group, function)
              ('not_equal', 0, None),
          ]),
          (re.compile(r'='), [
              # (terminal, group, function)
              ('equal', 0, None),
          ]),
          (re.compile(r'\.'), [
              # (terminal, group, function)
              ('dot', 0, None),
          ]),
          (re.compile(r'\{'), [
              # (terminal, group, function)
              ('lbrace', 0, None),
          ]),
          (re.compile(r'\}'), [
              # (terminal, group, function)
              ('rbrace', 0, None),
          ]),
          (re.compile(r'\('), [
              # (terminal, group, function)
              ('lparen', 0, None),
          ]),
          (re.compile(r'\)'), [
              # (terminal, group, function)
              ('rparen', 0, None),
          ]),
          (re.compile(r'\['), [
              # (terminal, group, function)
              ('lsquare', 0, None),
          ]),
          (re.compile(r'\]'), [
              # (terminal, group, function)
              ('rsquare', 0, None),
          ]),
          (re.compile(r'\+'), [
              # (terminal, group, function)
              ('plus', 0, None),
          ]),
          (re.compile(r'\*'), [
              # (terminal, group, function)
              ('asterisk', 0, None),
          ]),
          (re.compile(r'-'), [
              # (terminal, group, function)
              ('dash', 0, None),
          ]),
          (re.compile(r'/'), [
              # (terminal, group, function)
              ('slash', 0, None),
          ]),
          (re.compile(r'%'), [
              # (terminal, group, function)
              ('percent', 0, None),
          ]),
          (re.compile(r'<='), [
              # (terminal, group, function)
              ('lteq', 0, None),
          ]),
          (re.compile(r'<'), [
              # (terminal, group, function)
              ('lt', 0, None),
          ]),
          (re.compile(r'>='), [
              # (terminal, group, function)
              ('gteq', 0, None),
          ]),
          (re.compile(r'>'), [
              # (terminal, group, function)
              ('gt', 0, None),
          ]),
          (re.compile(r'!'), [
              # (terminal, group, function)
              ('not', 0, None),
          ]),
          (re.compile(r'\"'), [
              # (terminal, group, function)
              ('quote', 0, None),
              LexerStackPush('dquote_string'),
          ]),
          (re.compile(r'\''), [
              # (terminal, group, function)
              ('quote', 0, None),
              LexerStackPush('squote_string'),
          ]),
          (re.compile(r'\?'), [
              # (terminal, group, function)
              ('qmark', 0, None),
          ]),
          (re.compile(r'-?[0-9]+\.[0-9]+'), [
              # (terminal, group, function)
              ('float', 0, None),
          ]),
          (re.compile(r'[0-9]+'), [
              # (terminal, group, function)
              ('integer', 0, None),
          ]),
        ]),
        'dquote_string': OrderedDict([
          (re.compile(r'\"'), [
              # (terminal, group, function)
              ('quote', 0, None),
              LexerAction('pop'),
          ]),
          (re.compile(r'\$\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'~\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'\\.'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
          (re.compile(r'[^\\\"\$~]+'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
          (re.compile(r'[~$](?!{)'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
          (re.compile(r'[^\"\n(\$\{)(~\{)]*'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
        ]),
        'squote_string': OrderedDict([
          (re.compile(r'\''), [
              # (terminal, group, function)
              ('quote', 0, None),
              LexerAction('pop'),
          ]),
          (re.compile(r'\$\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'~\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'\\.'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
          (re.compile(r'[^\\\'\$~]+'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
          (re.compile(r'[~$](?!{)'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
          (re.compile(r'[^\'\n(\$\{)(~\{)]*'), [
              # (terminal, group, function)
              ('string', 0, wdl_unescape),
          ]),
        ]),
        'awaiting_version_name': OrderedDict([
          (re.compile(r'\s+'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'1.0'), [
              # (terminal, group, function)
              ('version_name', 0, None),
              LexerStackPush('main'),
          ]),
        ]),
        'task_fqn': OrderedDict([
          (re.compile(r'\s+'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'[a-zA-Z]([a-zA-Z0-9_])*(\.[a-zA-Z]([a-zA-Z0-9_])*)*'), [
              # (terminal, group, function)
              ('fqn', 0, None),
              LexerAction('pop'),
          ]),
        ]),
        'scatter': OrderedDict([
          (re.compile(r'\s+'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'\('), [
              # (terminal, group, function)
              ('lparen', 0, None),
          ]),
          (re.compile(r'in(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('in', 0, None),
              LexerAction('pop'),
          ]),
          (re.compile(r'[a-zA-Z]([a-zA-Z0-9_])*'), [
              # (terminal, group, function)
              ('identifier', 0, None),
          ]),
        ]),
        'raw_command': OrderedDict([
          (re.compile(r'\{'), [
              # (terminal, group, function)
              ('raw_cmd_start', 0, None),
          ]),
          (re.compile(r'\}'), [
              # (terminal, group, function)
              ('raw_cmd_end', 0, None),
              LexerAction('pop'),
          ]),
          (re.compile(r'\$\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'~\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'(.*?)(?=\$\{|~\{|\})', re.DOTALL), [
              # (terminal, group, function)
              ('cmd_part', 0, None),
          ]),
        ]),
        'raw_command2': OrderedDict([
          (re.compile(r'<<<'), [
              # (terminal, group, function)
              ('raw_cmd_start', 0, None),
          ]),
          (re.compile(r'>>>'), [
              # (terminal, group, function)
              ('raw_cmd_end', 0, None),
              LexerAction('pop'),
          ]),
          (re.compile(r'~\{'), [
              # (terminal, group, function)
              ('expression_placeholder_start', 0, None),
              LexerStackPush('expression_placeholder'),
          ]),
          (re.compile(r'(.*?)(?=~\{|>>>)', re.DOTALL), [
              # (terminal, group, function)
              ('cmd_part', 0, None),
          ]),
        ]),
        'expression_placeholder': OrderedDict([
          (re.compile(r'\s+'), [
              # (terminal, group, function)
          ]),
          (re.compile(r'\}'), [
              # (terminal, group, function)
              ('expression_placeholder_end', 0, None),
              LexerAction('pop'),
          ]),
          (re.compile(r'\['), [
              # (terminal, group, function)
              ('lsquare', 0, None),
          ]),
          (re.compile(r'\]'), [
              # (terminal, group, function)
              ('rsquare', 0, None),
          ]),
          (re.compile(r'='), [
              # (terminal, group, function)
              ('equal', 0, None),
          ]),
          (re.compile(r'\+'), [
              # (terminal, group, function)
              ('plus', 0, None),
          ]),
          (re.compile(r'\*'), [
              # (terminal, group, function)
              ('asterisk', 0, None),
          ]),
          (re.compile(r'[0-9]+'), [
              # (terminal, group, function)
              ('integer', 0, None),
          ]),
          (re.compile(r'if'), [
              # (terminal, group, function)
              ('if', 0, None),
          ]),
          (re.compile(r'else'), [
              # (terminal, group, function)
              ('else', 0, None),
          ]),
          (re.compile(r'then'), [
              # (terminal, group, function)
              ('then', 0, None),
          ]),
          (re.compile(r'[a-zA-Z]([a-zA-Z0-9_])*(?=\s*=)'), [
              # (terminal, group, function)
              ('cmd_attr_hint', None, None),
              ('identifier', 0, None),
          ]),
          (re.compile(r'(true|false)(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('boolean', 0, None),
          ]),
          (re.compile(r'(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])'), [
              # (terminal, group, function)
              ('type', 0, None),
          ]),
          (re.compile(r'[a-zA-Z]([a-zA-Z0-9_])*'), [
              # (terminal, group, function)
              ('identifier', 0, None),
          ]),
          (re.compile(r':'), [
              # (terminal, group, function)
              ('colon', 0, None),
          ]),
          (re.compile(r','), [
              # (terminal, group, function)
              ('comma', 0, None),
          ]),
          (re.compile(r'\.'), [
              # (terminal, group, function)
              ('dot', 0, None),
          ]),
          (re.compile(r'=='), [
              # (terminal, group, function)
              ('double_equal', 0, None),
          ]),
          (re.compile(r'\|\|'), [
              # (terminal, group, function)
              ('double_pipe', 0, None),
          ]),
          (re.compile(r'\&\&'), [
              # (terminal, group, function)
              ('double_ampersand', 0, None),
          ]),
          (re.compile(r'!='), [
              # (terminal, group, function)
              ('not_equal', 0, None),
          ]),
          (re.compile(r'='), [
              # (terminal, group, function)
              ('equal', 0, None),
          ]),
          (re.compile(r'\.'), [
              # (terminal, group, function)
              ('dot', 0, None),
          ]),
          (re.compile(r'\{'), [
              # (terminal, group, function)
              ('lbrace', 0, None),
          ]),
          (re.compile(r'\('), [
              # (terminal, group, function)
              ('lparen', 0, None),
          ]),
          (re.compile(r'\)'), [
              # (terminal, group, function)
              ('rparen', 0, None),
          ]),
          (re.compile(r'\['), [
              # (terminal, group, function)
              ('lsquare', 0, None),
          ]),
          (re.compile(r'\]'), [
              # (terminal, group, function)
              ('rsquare', 0, None),
          ]),
          (re.compile(r'\+'), [
              # (terminal, group, function)
              ('plus', 0, None),
          ]),
          (re.compile(r'\*'), [
              # (terminal, group, function)
              ('asterisk', 0, None),
          ]),
          (re.compile(r'-'), [
              # (terminal, group, function)
              ('dash', 0, None),
          ]),
          (re.compile(r'/'), [
              # (terminal, group, function)
              ('slash', 0, None),
          ]),
          (re.compile(r'%'), [
              # (terminal, group, function)
              ('percent', 0, None),
          ]),
          (re.compile(r'<='), [
              # (terminal, group, function)
              ('lteq', 0, None),
          ]),
          (re.compile(r'<'), [
              # (terminal, group, function)
              ('lt', 0, None),
          ]),
          (re.compile(r'>='), [
              # (terminal, group, function)
              ('gteq', 0, None),
          ]),
          (re.compile(r'>'), [
              # (terminal, group, function)
              ('gt', 0, None),
          ]),
          (re.compile(r'!'), [
              # (terminal, group, function)
              ('not', 0, None),
          ]),
          (re.compile(r'\"'), [
              # (terminal, group, function)
              ('quote', 0, None),
              LexerStackPush('dquote_string'),
          ]),
          (re.compile(r'\''), [
              # (terminal, group, function)
              ('quote', 0, None),
              LexerStackPush('squote_string'),
          ]),
          (re.compile(r'-?[0-9]+\.[0-9]+'), [
              # (terminal, group, function)
              ('float', 0, None),
          ]),
          (re.compile(r'[0-9]+'), [
              # (terminal, group, function)
              ('integer', 0, None),
          ]),
        ]),
    }
    def _advance_line_col(self, string, length, line, col):
        for i in range(length):
            if string[i] == '\n':
                line += 1
                col = 1
            else:
                col += 1
        return (line, col)
    def _advance_string(self, ctx, string):
        (ctx.line, ctx.col) = self._advance_line_col(string, len(string), ctx.line, ctx.col)
        ctx.string = ctx.string[len(string):]
    def _next(self, ctx, debug=False):
        for regex, outputs in self.regex[ctx.stack[-1]].items():
            if debug:
                from xtermcolor import colorize
                token_count = len(ctx.tokens)
                print('{1} ({2}, {3}) regex: {0}'.format(
                    colorize(regex.pattern, ansi=40), colorize(ctx.string[:20].replace('\n', '\\n'), ansi=15), ctx.line, ctx.col)
                )
            match = regex.match(ctx.string)
            if match:
                ctx.re_match = match
                for output in outputs:
                    if isinstance(output, tuple):
                        (terminal, group, function) = output
                        function = function if function else default_action
                        source_string = match.group(group) if group is not None else ''
                        (group_line, group_col) = self._advance_line_col(ctx.string, match.start(group) if group else 0, ctx.line, ctx.col)
                        function(
                            ctx,
                            terminal,
                            source_string,
                            group_line,
                            group_col
                        )
                        if debug:
                            print('    matched: {}'.format(colorize(match.group(0).replace('\n', '\\n'), ansi=3)))
                            for token in ctx.tokens[token_count:]:
                                print('    emit: [{}] [{}, {}] [{}] stack:{} context:{}'.format(
                                    colorize(token.str, ansi=9),
                                    colorize(str(token.line), ansi=5),
                                    colorize(str(token.col), ansi=5),
                                    colorize(token.source_string, ansi=3),
                                    colorize(str(ctx.stack), ansi=4),
                                    colorize(str(ctx.user_context), ansi=13)
                                ))
                            token_count = len(ctx.tokens)
                    if isinstance(output, LexerStackPush):
                        ctx.stack.append(output.mode)
                        if debug:
                            print('    push on stack: {}'.format(colorize(output.mode, ansi=4)))
                    if isinstance(output, LexerAction):
                        if output.action == 'pop':
                            mode = ctx.stack.pop()
                            if debug:
                                print('    pop off stack: {}'.format(colorize(mode, ansi=4)))
                self._advance_string(ctx, match.group(0))
                return len(match.group(0)) > 0
        return False
    def lex(self, string, resource, errors=None, debug=False):
        if errors is None:
            errors = DefaultSyntaxErrorHandler()
        string_copy = string
        user_context = init()
        ctx = LexerContext(string, resource, errors, user_context)
        while len(ctx.string):
            matched = self._next(ctx, debug)
            if matched == False:
                raise ctx.errors.unrecognized_token(string_copy, ctx.line, ctx.col)
        destroy(ctx.user_context)
        filtered = post_filter(ctx.tokens)
        return filtered
def lex(source, resource, errors=None, debug=False):
    return TokenStream(HermesLexer().lex(source, resource, errors, debug))
# Main #
def cli():
    if len(sys.argv) != 3 or (sys.argv[1] not in ['parsetree', 'ast'] and sys.argv[1] != 'tokens'):
        sys.stderr.write("Usage: {0} parsetree <source>\n".format(argv[0]))
        sys.stderr.write("Usage: {0} ast <source>\n".format(argv[0]))
        sys.stderr.write("Usage: {0} tokens <source>\n".format(argv[0]))
        sys.exit(-1)
    try:
        with open(sys.argv[2]) as fp:
            tokens = lex(fp.read(), os.path.basename(sys.argv[2]))
    except SyntaxError as error:
        sys.exit(error)
    if sys.argv[1] in ['parsetree', 'ast']:
        try:
            tree = parse(tokens)
            if sys.argv[1] == 'parsetree':
                print(tree.dumps(indent=2))
            else:
                ast = tree.ast()
                print(ast.dumps(indent=2) if ast else ast)
        except SyntaxError as error:
            print(error)
    if sys.argv[1] == 'tokens':
        for token in tokens:
            print(token)
if __name__ == '__main__':
    cli()
