# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: contact@leia.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from leiaapi.generated.api_client import ApiClient


class ModelApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def apply_model_async(self, token, model_id, document_ids, **kwargs):  # noqa: E501
        """Asynchronously applies a model on documents  # noqa: E501

        Asynchronously applies an accessible model on accessible documents and returns a Job, that will have to be polled to get the result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_model_async(token, model_id, document_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id or the short name of the model to apply on the document (required)
        :param list[str] document_ids: Comma separated list of document ids to process (required)
        :param ApplyBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :param FormatTypes format_type: The format in which the data should be returned. If empty, will return an array of key-value items. If it is classification, the result will be a Classification object.
        :param str execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :param str page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages)  You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object model_params: Additional parameters that will be passed as is to the model
        :param bool block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apply_model_async_with_http_info(token, model_id, document_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.apply_model_async_with_http_info(token, model_id, document_ids, **kwargs)  # noqa: E501
            return data

    def apply_model_async_with_http_info(self, token, model_id, document_ids, **kwargs):  # noqa: E501
        """Asynchronously applies a model on documents  # noqa: E501

        Asynchronously applies an accessible model on accessible documents and returns a Job, that will have to be polled to get the result  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_model_async_with_http_info(token, model_id, document_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id or the short name of the model to apply on the document (required)
        :param list[str] document_ids: Comma separated list of document ids to process (required)
        :param ApplyBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :param FormatTypes format_type: The format in which the data should be returned. If empty, will return an array of key-value items. If it is classification, the result will be a Classification object.
        :param str execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :param str page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages)  You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object model_params: Additional parameters that will be passed as is to the model
        :param bool block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'model_id', 'document_ids', 'body', 'tag', 'format_type', 'execute_after_id', 'page_range', 'callback_url', 'model_params', 'block_processing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_model_async" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `apply_model_async`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `apply_model_async`")  # noqa: E501
        # verify the required parameter 'document_ids' is set
        if ('document_ids' not in params or
                params['document_ids'] is None):
            raise ValueError("Missing the required parameter `document_ids` when calling `apply_model_async`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501
        if 'document_ids' in params:
            path_params['document_ids'] = params['document_ids']  # noqa: E501
            collection_formats['document_ids'] = 'multi'  # noqa: E501

        query_params = []
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'format_type' in params:
            query_params.append(('format_type', params['format_type']))  # noqa: E501
        if 'execute_after_id' in params:
            query_params.append(('execute_after_id', params['execute_after_id']))  # noqa: E501
        if 'page_range' in params:
            query_params.append(('page_range', params['page_range']))  # noqa: E501
        if 'callback_url' in params:
            query_params.append(('callback_url', params['callback_url']))  # noqa: E501
        if 'model_params' in params:
            query_params.append(('model_params', params['model_params']))  # noqa: E501
        if 'block_processing' in params:
            query_params.append(('block_processing', params['block_processing']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/model/{model_id}/apply/{document_ids}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model(self, token, model_id, **kwargs):  # noqa: E501
        """Get a model  # noqa: E501

        Get a model in the system that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model(token, model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id or the short name of the model to get (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_with_http_info(token, model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_with_http_info(token, model_id, **kwargs)  # noqa: E501
            return data

    def get_model_with_http_info(self, token, model_id, **kwargs):  # noqa: E501
        """Get a model  # noqa: E501

        Get a model in the system that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_with_http_info(token, model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id or the short name of the model to get (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/model/{model_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_models(self, token, **kwargs):  # noqa: E501
        """Lists models (paginated)  # noqa: E501

        Lists models corresponding to the filters that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: Filter by id
        :param ModelTypes model_type: Filter by type
        :param str name: Filter by name
        :param str short_name: Filter by short name
        :param str description: Gets models that contain this string in their description
        :param list[ModelInputTypes] input_types: Filter by input type
        :param list[str] tags: If specified, filters the models by tag
        :param datetime created_after: If specified, keeps only models created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only models created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param bool only_mine: If true, will list only models that strictly belong to logged in application (and not all the models that it can use) (false by default)
        :param str sort: If specified, sorts the models by a list of existing parameters separated by commas. Can be 'application_id', 'creation_time', 'name', 'description', 'model_type'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :param int offset: Number of the first model to send (pagination)
        :param int limit: Maximum number of models to send (pagination)
        :return: list[Model]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_models_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_models_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_models_with_http_info(self, token, **kwargs):  # noqa: E501
        """Lists models (paginated)  # noqa: E501

        Lists models corresponding to the filters that the application can access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: Filter by id
        :param ModelTypes model_type: Filter by type
        :param str name: Filter by name
        :param str short_name: Filter by short name
        :param str description: Gets models that contain this string in their description
        :param list[ModelInputTypes] input_types: Filter by input type
        :param list[str] tags: If specified, filters the models by tag
        :param datetime created_after: If specified, keeps only models created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only models created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param bool only_mine: If true, will list only models that strictly belong to logged in application (and not all the models that it can use) (false by default)
        :param str sort: If specified, sorts the models by a list of existing parameters separated by commas. Can be 'application_id', 'creation_time', 'name', 'description', 'model_type'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :param int offset: Number of the first model to send (pagination)
        :param int limit: Maximum number of models to send (pagination)
        :return: list[Model]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'model_id', 'model_type', 'name', 'short_name', 'description', 'input_types', 'tags', 'created_after', 'created_before', 'only_mine', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_models`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'model_id' in params:
            query_params.append(('model_id', params['model_id']))  # noqa: E501
        if 'model_type' in params:
            query_params.append(('model_type', params['model_type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'short_name' in params:
            query_params.append(('short_name', params['short_name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'input_types' in params:
            query_params.append(('input_types', params['input_types']))  # noqa: E501
            collection_formats['input_types'] = 'multi'  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'only_mine' in params:
            query_params.append(('only_mine', params['only_mine']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/model', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Model]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tag_model(self, token, model_id, tag, **kwargs):  # noqa: E501
        """Tags a model  # noqa: E501

        Tags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tag_model(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id of the model (required)
        :param str tag: The tag to add to the model (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tag_model_with_http_info(token, model_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.tag_model_with_http_info(token, model_id, tag, **kwargs)  # noqa: E501
            return data

    def tag_model_with_http_info(self, token, model_id, tag, **kwargs):  # noqa: E501
        """Tags a model  # noqa: E501

        Tags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tag_model_with_http_info(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id of the model (required)
        :param str tag: The tag to add to the model (required)
        :return: Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'model_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `tag_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `tag_model`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `tag_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/model/{model_id}/tag/{tag}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def train_model_async(self, token, model_module, documents_tag, **kwargs):  # noqa: E501
        """Asynchronously trains a model on documents (admin only)  # noqa: E501

        Asynchronously trains a model on accessible documents and returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.train_model_async(token, model_module, documents_tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_module: The module name of the model to train on documents (required)
        :param str documents_tag: The tag of the documents to train with (required)
        :param TrainBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str model_name: The future name of the model in database
        :param str short_name: The new short name of the model
        :param str description: The description of the model
        :param int ttl: The TTL of the model in seconds, if running in worker mode (negative for infinite TTL, default is 200)
        :param list[str] allowed_application_ids: The applications allowed to use this model
        :param bool allow_all_applications: Is this model allowed for everyone ?
        :param list[str] tags: The tags of the model
        :param str execute_after_id: The job that is a prerequisite for this job to run
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object model_params: Additional parameters that will be passed as is to the train method
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.train_model_async_with_http_info(token, model_module, documents_tag, **kwargs)  # noqa: E501
        else:
            (data) = self.train_model_async_with_http_info(token, model_module, documents_tag, **kwargs)  # noqa: E501
            return data

    def train_model_async_with_http_info(self, token, model_module, documents_tag, **kwargs):  # noqa: E501
        """Asynchronously trains a model on documents (admin only)  # noqa: E501

        Asynchronously trains a model on accessible documents and returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.train_model_async_with_http_info(token, model_module, documents_tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_module: The module name of the model to train on documents (required)
        :param str documents_tag: The tag of the documents to train with (required)
        :param TrainBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str model_name: The future name of the model in database
        :param str short_name: The new short name of the model
        :param str description: The description of the model
        :param int ttl: The TTL of the model in seconds, if running in worker mode (negative for infinite TTL, default is 200)
        :param list[str] allowed_application_ids: The applications allowed to use this model
        :param bool allow_all_applications: Is this model allowed for everyone ?
        :param list[str] tags: The tags of the model
        :param str execute_after_id: The job that is a prerequisite for this job to run
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object model_params: Additional parameters that will be passed as is to the train method
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'model_module', 'documents_tag', 'body', 'model_name', 'short_name', 'description', 'ttl', 'allowed_application_ids', 'allow_all_applications', 'tags', 'execute_after_id', 'callback_url', 'model_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method train_model_async" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `train_model_async`")  # noqa: E501
        # verify the required parameter 'model_module' is set
        if ('model_module' not in params or
                params['model_module'] is None):
            raise ValueError("Missing the required parameter `model_module` when calling `train_model_async`")  # noqa: E501
        # verify the required parameter 'documents_tag' is set
        if ('documents_tag' not in params or
                params['documents_tag'] is None):
            raise ValueError("Missing the required parameter `documents_tag` when calling `train_model_async`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_module' in params:
            path_params['model_module'] = params['model_module']  # noqa: E501
        if 'documents_tag' in params:
            path_params['documents_tag'] = params['documents_tag']  # noqa: E501

        query_params = []
        if 'model_name' in params:
            query_params.append(('model_name', params['model_name']))  # noqa: E501
        if 'short_name' in params:
            query_params.append(('short_name', params['short_name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501
        if 'allowed_application_ids' in params:
            query_params.append(('allowed_application_ids', params['allowed_application_ids']))  # noqa: E501
            collection_formats['allowed_application_ids'] = 'multi'  # noqa: E501
        if 'allow_all_applications' in params:
            query_params.append(('allow_all_applications', params['allow_all_applications']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'execute_after_id' in params:
            query_params.append(('execute_after_id', params['execute_after_id']))  # noqa: E501
        if 'callback_url' in params:
            query_params.append(('callback_url', params['callback_url']))  # noqa: E501
        if 'model_params' in params:
            query_params.append(('model_params', params['model_params']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/model/{model_module}/train/{documents_tag}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def untag_model(self, token, model_id, tag, **kwargs):  # noqa: E501
        """Untags a model  # noqa: E501

        Untags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.untag_model(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id of the model (required)
        :param str tag: The tag to delete from the model (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.untag_model_with_http_info(token, model_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.untag_model_with_http_info(token, model_id, tag, **kwargs)  # noqa: E501
            return data

    def untag_model_with_http_info(self, token, model_id, tag, **kwargs):  # noqa: E501
        """Untags a model  # noqa: E501

        Untags a model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.untag_model_with_http_info(token, model_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str model_id: The id of the model (required)
        :param str tag: The tag to delete from the model (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'model_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method untag_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `untag_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `untag_model`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `untag_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/model/{model_id}/tag/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
