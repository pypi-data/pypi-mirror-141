# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: contact@leia.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from leiaapi.generated.api_client import ApiClient


class ApplicationAdminApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def admin_create_application(self, token, **kwargs):  # noqa: E501
        """Adds a new application to the system (admin only)  # noqa: E501

        Adds a new application to the system. This method is only accessible to admins. An API key will be generated for the new application when calling this method. Note or store it carefully, it will not be recoverable after this call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_create_application(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param Application body:
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_create_application_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_create_application_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def admin_create_application_with_http_info(self, token, **kwargs):  # noqa: E501
        """Adds a new application to the system (admin only)  # noqa: E501

        Adds a new application to the system. This method is only accessible to admins. An API key will be generated for the new application when calling this method. Note or store it carefully, it will not be recoverable after this call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_create_application_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param Application body:
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_create_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_delete_always_on_schedule(self, token, application_id, always_on_schedule_id, **kwargs):  # noqa: E501
        """Removes a schedule from an application  # noqa: E501

        Removes a schedule from an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_delete_always_on_schedule(token, application_id, always_on_schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application (required)
        :param str always_on_schedule_id: The id of the schedule to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_delete_always_on_schedule_with_http_info(token, application_id, always_on_schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_delete_always_on_schedule_with_http_info(token, application_id, always_on_schedule_id, **kwargs)  # noqa: E501
            return data

    def admin_delete_always_on_schedule_with_http_info(self, token, application_id, always_on_schedule_id, **kwargs):  # noqa: E501
        """Removes a schedule from an application  # noqa: E501

        Removes a schedule from an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_delete_always_on_schedule_with_http_info(token, application_id, always_on_schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application (required)
        :param str always_on_schedule_id: The id of the schedule to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'always_on_schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_always_on_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_delete_always_on_schedule`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_delete_always_on_schedule`")  # noqa: E501
        # verify the required parameter 'always_on_schedule_id' is set
        if ('always_on_schedule_id' not in params or
                params['always_on_schedule_id'] is None):
            raise ValueError("Missing the required parameter `always_on_schedule_id` when calling `admin_delete_always_on_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'always_on_schedule_id' in params:
            path_params['always_on_schedule_id'] = params['always_on_schedule_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application/{application_id}/always_on_schedules/{always_on_schedule_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_delete_application(self, token, application_id, **kwargs):  # noqa: E501
        """Deletes an application (admin only)  # noqa: E501

        Retrieves a new application from the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_delete_application(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_delete_application_with_http_info(token, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_delete_application_with_http_info(token, application_id, **kwargs)  # noqa: E501
            return data

    def admin_delete_application_with_http_info(self, token, application_id, **kwargs):  # noqa: E501
        """Deletes an application (admin only)  # noqa: E501

        Retrieves a new application from the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_delete_application_with_http_info(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_delete_application`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_delete_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application/{application_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_edit_application(self, token, application_id, **kwargs):  # noqa: E501
        """Modifies an existing application in the system (admin only)  # noqa: E501

        Modifies an application already in the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_edit_application(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to modify (required)
        :param str application_name: The new name of the application
        :param str email: The new email of the application
        :param str first_name: The new first name of the application
        :param str last_name: The new last name of the application
        :param str default_job_callback_url: The new default_job_callback_url of the application
        :param bool dedicated_workers: Should this application use dedicated workers ?
        :param int dedicated_workers_ttl: When using dedicated workers, TTL of the worker (in seconds)
        :param int dedicated_workers_max_models: When using dedicated workers, maximum number of models loaded at the same time
        :param bool reduce_callback_payloads: Specifies if the callback should be sent as is, or if the potential base64 encoded documents generated should be saved as sub documents of the original document
        :param int always_on_number: Adds a schedule for always on workers. Will start number always on workers when start time happens and stop them at stop time. (Check always_on_* parameters to set other parameters)
        :param list[int] always_on_start_days: Adds a schedule for always on workers. Set the day(s) of the week at which the worker will start (1 is Monday, 7 is Sunday, comma separated). Stop day will be the same day. (Check always_on_* parameters to set other parameters)
        :param int always_on_start_hour: Adds a schedule for always on workers. Set the hour at which the worker will start (between 0 and 23). (Check always_on_* parameters to set other parameters)
        :param int always_on_stop_hour: Adds a schedule for always on workers. Set the hour at which the worker will stop (between 0 and 23, stop must happen after start). (Check always_on_* parameters to set other parameters)
        :param int always_on_start_minute: Adds a schedule for always on workers. Set the minute at which the worker will start (between 0 and 59). (Check always_on_* parameters to set other parameters)
        :param int always_on_stop_minute: Adds a schedule for always on workers. Set the minute at which the worker will stop (between 0 and 59, stop must happen after start). (Check always_on_* parameters to set other parameters)
        :param list[str] always_on_workers_model_ids: When using dedicated workers with always on schedule, the models that should be loaded on start of the worker
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_edit_application_with_http_info(token, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_edit_application_with_http_info(token, application_id, **kwargs)  # noqa: E501
            return data

    def admin_edit_application_with_http_info(self, token, application_id, **kwargs):  # noqa: E501
        """Modifies an existing application in the system (admin only)  # noqa: E501

        Modifies an application already in the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_edit_application_with_http_info(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to modify (required)
        :param str application_name: The new name of the application
        :param str email: The new email of the application
        :param str first_name: The new first name of the application
        :param str last_name: The new last name of the application
        :param str default_job_callback_url: The new default_job_callback_url of the application
        :param bool dedicated_workers: Should this application use dedicated workers ?
        :param int dedicated_workers_ttl: When using dedicated workers, TTL of the worker (in seconds)
        :param int dedicated_workers_max_models: When using dedicated workers, maximum number of models loaded at the same time
        :param bool reduce_callback_payloads: Specifies if the callback should be sent as is, or if the potential base64 encoded documents generated should be saved as sub documents of the original document
        :param int always_on_number: Adds a schedule for always on workers. Will start number always on workers when start time happens and stop them at stop time. (Check always_on_* parameters to set other parameters)
        :param list[int] always_on_start_days: Adds a schedule for always on workers. Set the day(s) of the week at which the worker will start (1 is Monday, 7 is Sunday, comma separated). Stop day will be the same day. (Check always_on_* parameters to set other parameters)
        :param int always_on_start_hour: Adds a schedule for always on workers. Set the hour at which the worker will start (between 0 and 23). (Check always_on_* parameters to set other parameters)
        :param int always_on_stop_hour: Adds a schedule for always on workers. Set the hour at which the worker will stop (between 0 and 23, stop must happen after start). (Check always_on_* parameters to set other parameters)
        :param int always_on_start_minute: Adds a schedule for always on workers. Set the minute at which the worker will start (between 0 and 59). (Check always_on_* parameters to set other parameters)
        :param int always_on_stop_minute: Adds a schedule for always on workers. Set the minute at which the worker will stop (between 0 and 59, stop must happen after start). (Check always_on_* parameters to set other parameters)
        :param list[str] always_on_workers_model_ids: When using dedicated workers with always on schedule, the models that should be loaded on start of the worker
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'application_name', 'email', 'first_name', 'last_name', 'default_job_callback_url', 'dedicated_workers', 'dedicated_workers_ttl', 'dedicated_workers_max_models', 'reduce_callback_payloads', 'always_on_number', 'always_on_start_days', 'always_on_start_hour', 'always_on_stop_hour', 'always_on_start_minute', 'always_on_stop_minute', 'always_on_workers_model_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_edit_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_edit_application`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_edit_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501

        query_params = []
        if 'application_name' in params:
            query_params.append(('application_name', params['application_name']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'first_name' in params:
            query_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            query_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'default_job_callback_url' in params:
            query_params.append(('default_job_callback_url', params['default_job_callback_url']))  # noqa: E501
        if 'dedicated_workers' in params:
            query_params.append(('dedicated_workers', params['dedicated_workers']))  # noqa: E501
        if 'dedicated_workers_ttl' in params:
            query_params.append(('dedicated_workers_ttl', params['dedicated_workers_ttl']))  # noqa: E501
        if 'dedicated_workers_max_models' in params:
            query_params.append(('dedicated_workers_max_models', params['dedicated_workers_max_models']))  # noqa: E501
        if 'reduce_callback_payloads' in params:
            query_params.append(('reduce_callback_payloads', params['reduce_callback_payloads']))  # noqa: E501
        if 'always_on_number' in params:
            query_params.append(('always_on_number', params['always_on_number']))  # noqa: E501
        if 'always_on_start_days' in params:
            query_params.append(('always_on_start_days', params['always_on_start_days']))  # noqa: E501
            collection_formats['always_on_start_days'] = 'multi'  # noqa: E501
        if 'always_on_start_hour' in params:
            query_params.append(('always_on_start_hour', params['always_on_start_hour']))  # noqa: E501
        if 'always_on_stop_hour' in params:
            query_params.append(('always_on_stop_hour', params['always_on_stop_hour']))  # noqa: E501
        if 'always_on_start_minute' in params:
            query_params.append(('always_on_start_minute', params['always_on_start_minute']))  # noqa: E501
        if 'always_on_stop_minute' in params:
            query_params.append(('always_on_stop_minute', params['always_on_stop_minute']))  # noqa: E501
        if 'always_on_workers_model_ids' in params:
            query_params.append(('always_on_workers_model_ids', params['always_on_workers_model_ids']))  # noqa: E501
            collection_formats['always_on_workers_model_ids'] = 'multi'  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application/{application_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_application(self, token, application_id, **kwargs):  # noqa: E501
        """Retrieves an application (admin only)  # noqa: E501

        Retrieves a new application from the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_application(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application to retrieve (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_application_with_http_info(token, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_application_with_http_info(token, application_id, **kwargs)  # noqa: E501
            return data

    def admin_get_application_with_http_info(self, token, application_id, **kwargs):  # noqa: E501
        """Retrieves an application (admin only)  # noqa: E501

        Retrieves a new application from the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_application_with_http_info(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application to retrieve (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_application`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_get_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application/{application_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_applications(self, token, **kwargs):  # noqa: E501
        """Retrieves applications (admin only) (paginated)  # noqa: E501

        Retrieves applications from the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_applications(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: If specified, filters by application id
        :param str email: If specified, filters by application email
        :param str application_name: If specified, filters by application name
        :param str first_name: If specified, filters by application first_name
        :param str last_name: If specified, filters by application last_name
        :param ApplicationTypes application_type: If specified, filters by application application_type
        :param datetime created_after: If specified, keeps only applications created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only applications created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param bool dedicated_workers: If specified, filters by dedicated_workers value
        :param int offset: Number of the first document to send (pagination)
        :param int limit: Maximum number of documents to send (pagination)
        :param str sort: If specified, sorts the applications by a list of existing parameters separated by commas. Can be 'application_name', 'application_type', 'creation_time', 'first_name', 'last_name', 'email', 'dedicated_workers'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_applications_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_applications_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def admin_get_applications_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves applications (admin only) (paginated)  # noqa: E501

        Retrieves applications from the system. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_applications_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: If specified, filters by application id
        :param str email: If specified, filters by application email
        :param str application_name: If specified, filters by application name
        :param str first_name: If specified, filters by application first_name
        :param str last_name: If specified, filters by application last_name
        :param ApplicationTypes application_type: If specified, filters by application application_type
        :param datetime created_after: If specified, keeps only applications created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only applications created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param bool dedicated_workers: If specified, filters by dedicated_workers value
        :param int offset: Number of the first document to send (pagination)
        :param int limit: Maximum number of documents to send (pagination)
        :param str sort: If specified, sorts the applications by a list of existing parameters separated by commas. Can be 'application_name', 'application_type', 'creation_time', 'first_name', 'last_name', 'email', 'dedicated_workers'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'email', 'application_name', 'first_name', 'last_name', 'application_type', 'created_after', 'created_before', 'dedicated_workers', 'offset', 'limit', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_applications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_applications`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_id' in params:
            query_params.append(('application_id', params['application_id']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'application_name' in params:
            query_params.append(('application_name', params['application_name']))  # noqa: E501
        if 'first_name' in params:
            query_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            query_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'application_type' in params:
            query_params.append(('application_type', params['application_type']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'dedicated_workers' in params:
            query_params.append(('dedicated_workers', params['dedicated_workers']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Application]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_reset_api_key(self, token, application_id, **kwargs):  # noqa: E501
        """Resets an API key (admin only)  # noqa: E501

        Resets the API key of the application corresponding to application_id, and returns a new one. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_reset_api_key(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application to reset (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_reset_api_key_with_http_info(token, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_reset_api_key_with_http_info(token, application_id, **kwargs)  # noqa: E501
            return data

    def admin_reset_api_key_with_http_info(self, token, application_id, **kwargs):  # noqa: E501
        """Resets an API key (admin only)  # noqa: E501

        Resets the API key of the application corresponding to application_id, and returns a new one. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_reset_api_key_with_http_info(token, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The id of the application to reset (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_reset_api_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_reset_api_key`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_reset_api_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/application/{application_id}/reset_api_key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
