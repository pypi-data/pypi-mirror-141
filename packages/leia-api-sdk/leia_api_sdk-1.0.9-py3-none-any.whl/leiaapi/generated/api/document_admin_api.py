# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: contact@leia.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from leiaapi.generated.api_client import ApiClient


class DocumentAdminApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def admin_create_document(self, body, token, filename, application_id, **kwargs):  # noqa: E501
        """Uploads a document to the Leia API (admin only)  # noqa: E501

        Uploads a document to Leia API for future use. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_create_document(body, token, filename, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object body: (required)
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str filename: The name of the file (if present, extension will be separated from filename in metadata of the document) (required)
        :param str application_id: The application that will own the model (required)
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :param list[str] tags: The tags of the document
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_create_document_with_http_info(body, token, filename, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_create_document_with_http_info(body, token, filename, application_id, **kwargs)  # noqa: E501
            return data

    def admin_create_document_with_http_info(self, body, token, filename, application_id, **kwargs):  # noqa: E501
        """Uploads a document to the Leia API (admin only)  # noqa: E501

        Uploads a document to Leia API for future use. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_create_document_with_http_info(body, token, filename, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object body: (required)
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str filename: The name of the file (if present, extension will be separated from filename in metadata of the document) (required)
        :param str application_id: The application that will own the model (required)
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :param list[str] tags: The tags of the document
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'token', 'filename', 'application_id', 'ttl', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `admin_create_document`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_create_document`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `admin_create_document`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_create_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_delete_document(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Deletes a document from Leia API (admin only)  # noqa: E501

        Deletes a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_delete_document(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to delete belongs (required)
        :param str document_id: The id of the document to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_delete_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_delete_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
            return data

    def admin_delete_document_with_http_info(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Deletes a document from Leia API (admin only)  # noqa: E501

        Deletes a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_delete_document_with_http_info(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to delete belongs (required)
        :param str document_id: The id of the document to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_delete_document`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_delete_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `admin_delete_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_edit_document(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Updates a document in Leia API (admin only)  # noqa: E501

        Updates metadata for a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_edit_document(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to update belongs (required)
        :param str document_id: The id of the document to update (required)
        :param str filename: The new file name of the document
        :param int rotation_angle: The new rotation angle of the document
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_edit_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_edit_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
            return data

    def admin_edit_document_with_http_info(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Updates a document in Leia API (admin only)  # noqa: E501

        Updates metadata for a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_edit_document_with_http_info(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to update belongs (required)
        :param str document_id: The id of the document to update (required)
        :param str filename: The new file name of the document
        :param int rotation_angle: The new rotation angle of the document
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_id', 'filename', 'rotation_angle', 'ttl']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_edit_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_edit_document`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_edit_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `admin_edit_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'rotation_angle' in params:
            query_params.append(('rotation_angle', params['rotation_angle']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_document(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves a document from Leia API as metadata. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_document(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to retrieve belongs (required)
        :param str document_id: The id of the document to retrieve (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_document_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
            return data

    def admin_get_document_with_http_info(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves a document from Leia API as metadata. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_document_with_http_info(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to retrieve belongs (required)
        :param str document_id: The id of the document to retrieve (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_document`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_get_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `admin_get_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_document_contents(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves the binary contents of a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_document_contents(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to retrieve belongs (required)
        :param str document_id: The id of the document to retrieve (required)
        :param int max_size: Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension
        :param int jpeg_compression: JPEG compression rate, in percent (only applicable for documents of type image)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_document_contents_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_document_contents_with_http_info(token, application_id, document_id, **kwargs)  # noqa: E501
            return data

    def admin_get_document_contents_with_http_info(self, token, application_id, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API (admin only)  # noqa: E501

        Retrieves the binary contents of a document from Leia API. This method is only accessible to admins   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_document_contents_with_http_info(token, application_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to retrieve belongs (required)
        :param str document_id: The id of the document to retrieve (required)
        :param int max_size: Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension
        :param int jpeg_compression: JPEG compression rate, in percent (only applicable for documents of type image)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_id', 'max_size', 'jpeg_compression']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_document_contents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_document_contents`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_get_document_contents`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `admin_get_document_contents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []
        if 'max_size' in params:
            query_params.append(('max_size', params['max_size']))  # noqa: E501
        if 'jpeg_compression' in params:
            query_params.append(('jpeg_compression', params['jpeg_compression']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}/file_contents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_documents(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API as JSON metadata. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_documents(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document
        :param str application_id: The application that owns the documents
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param str tag_result: Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result
        :param str sort: If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :param int offset: Number of the first document to send (pagination)
        :param int limit: Maximum number of documents to send (pagination)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_documents_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_documents_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def admin_get_documents_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API as JSON metadata. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_documents_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document
        :param str application_id: The application that owns the documents
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param str tag_result: Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result
        :param str sort: If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :param int offset: Number of the first document to send (pagination)
        :param int limit: Maximum number of documents to send (pagination)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'tags', 'created_after', 'created_before', 'tag_result', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_documents`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'document_id' in params:
            query_params.append(('document_id', params['document_id']))  # noqa: E501
        if 'application_id' in params:
            query_params.append(('application_id', params['application_id']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'mime_type' in params:
            query_params.append(('mime_type', params['mime_type']))  # noqa: E501
        if 'original_id' in params:
            query_params.append(('original_id', params['original_id']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'tag_result' in params:
            query_params.append(('tag_result', params['tag_result']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/document', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Document]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_documents_tags(self, token, **kwargs):  # noqa: E501
        """Retrieves documents' tags from Leia API (admin only)  # noqa: E501

        Retrieves tags from documents. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_documents_tags(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: Restrict to tags belonging to this application
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_documents_tags_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_documents_tags_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def admin_get_documents_tags_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves documents' tags from Leia API (admin only)  # noqa: E501

        Retrieves tags from documents. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_documents_tags_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: Restrict to tags belonging to this application
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_documents_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_documents_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_id' in params:
            query_params.append(('application_id', params['application_id']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/document/tag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_get_documents_zip(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API in a zip file. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_documents_zip(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document
        :param str application_id: The application that owns the documents
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_get_documents_zip_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_get_documents_zip_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def admin_get_documents_zip_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (admin only) (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API in a zip file. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_get_documents_zip_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document
        :param str application_id: The application that owns the documents
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'tags', 'created_after', 'created_before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_documents_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_get_documents_zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'document_id' in params:
            query_params.append(('document_id', params['document_id']))  # noqa: E501
        if 'application_id' in params:
            query_params.append(('application_id', params['application_id']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'mime_type' in params:
            query_params.append(('mime_type', params['mime_type']))  # noqa: E501
        if 'original_id' in params:
            query_params.append(('original_id', params['original_id']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/zip'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/document/zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_tag_document(self, token, application_id, document_id, tag, **kwargs):  # noqa: E501
        """Tags a document (admin only)  # noqa: E501

        Tags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_tag_document(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to tag belongs (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to add to the document (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_tag_document_with_http_info(token, application_id, document_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_tag_document_with_http_info(token, application_id, document_id, tag, **kwargs)  # noqa: E501
            return data

    def admin_tag_document_with_http_info(self, token, application_id, document_id, tag, **kwargs):  # noqa: E501
        """Tags a document (admin only)  # noqa: E501

        Tags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_tag_document_with_http_info(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to tag belongs (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to add to the document (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_tag_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_tag_document`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_tag_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `admin_tag_document`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `admin_tag_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}/tag/{tag}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_transform_document_async(self, token, application_id, document_ids, output_type, **kwargs):  # noqa: E501
        """Asynchronously converts a document within Leia API (admin only)  # noqa: E501

        Asynchronously transforms a document from its current type to the output_type. May generate multiple new documents (for example converting a PDF to image will generate one new image document for each page of the PDF). Returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_transform_document_async(token, application_id, document_ids, output_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application id whose documents to transform belong to (required)
        :param list[str] document_ids: Comma separated list of document ids to process (required)
        :param TransformTypes output_type: The output type. May be:   * image (extract one image for each page in a PDF file)   * text (Use OCR on an image to get convert it to text)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params))  (required)
        :param TransformBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str input_tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :param str output_tag: The tag to add to the documents resulting from the transformation
        :param str execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :param str page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object transform_params: Free form parameters for the transformation
        :param bool block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_transform_document_async_with_http_info(token, application_id, document_ids, output_type, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_transform_document_async_with_http_info(token, application_id, document_ids, output_type, **kwargs)  # noqa: E501
            return data

    def admin_transform_document_async_with_http_info(self, token, application_id, document_ids, output_type, **kwargs):  # noqa: E501
        """Asynchronously converts a document within Leia API (admin only)  # noqa: E501

        Asynchronously transforms a document from its current type to the output_type. May generate multiple new documents (for example converting a PDF to image will generate one new image document for each page of the PDF). Returns a Job, that will have to be polled to get the result. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_transform_document_async_with_http_info(token, application_id, document_ids, output_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application id whose documents to transform belong to (required)
        :param list[str] document_ids: Comma separated list of document ids to process (required)
        :param TransformTypes output_type: The output type. May be:   * image (extract one image for each page in a PDF file)   * text (Use OCR on an image to get convert it to text)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params))  (required)
        :param TransformBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str input_tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :param str output_tag: The tag to add to the documents resulting from the transformation
        :param str execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :param str page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example ::2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object transform_params: Free form parameters for the transformation
        :param bool block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_ids', 'output_type', 'body', 'input_tag', 'output_tag', 'execute_after_id', 'page_range', 'callback_url', 'transform_params', 'block_processing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_transform_document_async" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_transform_document_async`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_transform_document_async`")  # noqa: E501
        # verify the required parameter 'document_ids' is set
        if ('document_ids' not in params or
                params['document_ids'] is None):
            raise ValueError("Missing the required parameter `document_ids` when calling `admin_transform_document_async`")  # noqa: E501
        # verify the required parameter 'output_type' is set
        if ('output_type' not in params or
                params['output_type'] is None):
            raise ValueError("Missing the required parameter `output_type` when calling `admin_transform_document_async`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_ids' in params:
            path_params['document_ids'] = params['document_ids']  # noqa: E501
            collection_formats['document_ids'] = 'multi'  # noqa: E501
        if 'output_type' in params:
            path_params['output_type'] = params['output_type']  # noqa: E501

        query_params = []
        if 'input_tag' in params:
            query_params.append(('input_tag', params['input_tag']))  # noqa: E501
        if 'output_tag' in params:
            query_params.append(('output_tag', params['output_tag']))  # noqa: E501
        if 'execute_after_id' in params:
            query_params.append(('execute_after_id', params['execute_after_id']))  # noqa: E501
        if 'page_range' in params:
            query_params.append(('page_range', params['page_range']))  # noqa: E501
        if 'callback_url' in params:
            query_params.append(('callback_url', params['callback_url']))  # noqa: E501
        if 'transform_params' in params:
            query_params.append(('transform_params', params['transform_params']))  # noqa: E501
        if 'block_processing' in params:
            query_params.append(('block_processing', params['block_processing']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_ids}/transform/{output_type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_untag_document(self, token, application_id, document_id, tag, **kwargs):  # noqa: E501
        """Untags an document (admin only)  # noqa: E501

        Untags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_untag_document(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to untag belongs (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to delete from the document (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.admin_untag_document_with_http_info(token, application_id, document_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.admin_untag_document_with_http_info(token, application_id, document_id, tag, **kwargs)  # noqa: E501
            return data

    def admin_untag_document_with_http_info(self, token, application_id, document_id, tag, **kwargs):  # noqa: E501
        """Untags an document (admin only)  # noqa: E501

        Untags a document. This method is only accessible to admins  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_untag_document_with_http_info(token, application_id, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str application_id: The application to which the document to untag belongs (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to delete from the document (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'application_id', 'document_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_untag_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `admin_untag_document`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `admin_untag_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `admin_untag_document`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `admin_untag_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['application_id'] = params['application_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/{application_id}/document/{document_id}/tag/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
