# coding: utf-8

"""
    LEIA RESTful API for AI

    Leia API  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: contact@leia.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from leiaapi.generated.api_client import ApiClient


class DocumentApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_document(self, body, token, filename, **kwargs):  # noqa: E501
        """Uploads a document to the Leia API  # noqa: E501

        Uploads a document to Leia API for future use   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_document(body, token, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object body: (required)
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str filename: The name of the file (if present, extension will be separated from filename in metadata of the document) (required)
        :param bool b64: Set to true if the body is b64 encoded
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :param list[str] tags: The tags of the document
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_document_with_http_info(body, token, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.create_document_with_http_info(body, token, filename, **kwargs)  # noqa: E501
            return data

    def create_document_with_http_info(self, body, token, filename, **kwargs):  # noqa: E501
        """Uploads a document to the Leia API  # noqa: E501

        Uploads a document to Leia API for future use   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_document_with_http_info(body, token, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Object body: (required)
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str filename: The name of the file (if present, extension will be separated from filename in metadata of the document) (required)
        :param bool b64: Set to true if the body is b64 encoded
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :param list[str] tags: The tags of the document
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'token', 'filename', 'b64', 'ttl', 'tags']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_document`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `create_document`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `create_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'b64' in params:
            query_params.append(('b64', params['b64']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_document(self, token, document_id, **kwargs):  # noqa: E501
        """Deletes a document from Leia API  # noqa: E501

        Deletes a document from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_document(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_document_with_http_info(token, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_document_with_http_info(token, document_id, **kwargs)  # noqa: E501
            return data

    def delete_document_with_http_info(self, token, document_id, **kwargs):  # noqa: E501
        """Deletes a document from Leia API  # noqa: E501

        Deletes a document from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_document_with_http_info(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `delete_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_document(self, token, document_id, **kwargs):  # noqa: E501
        """Updates a document in Leia API  # noqa: E501

        Updates metadata for a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_document(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to update (required)
        :param str filename: The new file name of the document
        :param int rotation_angle: The new rotation angle of the document
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_document_with_http_info(token, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_document_with_http_info(token, document_id, **kwargs)  # noqa: E501
            return data

    def edit_document_with_http_info(self, token, document_id, **kwargs):  # noqa: E501
        """Updates a document in Leia API  # noqa: E501

        Updates metadata for a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_document_with_http_info(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to update (required)
        :param str filename: The new file name of the document
        :param int rotation_angle: The new rotation angle of the document
        :param int ttl: The TTL (in seconds, not less than 60) for the document (if present, the document and any sub documents, annotations, or jobs linked to it will be deleted after the TTL is expired)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'filename', 'rotation_angle', 'ttl']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `edit_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `edit_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'rotation_angle' in params:
            query_params.append(('rotation_angle', params['rotation_angle']))  # noqa: E501
        if 'ttl' in params:
            query_params.append(('ttl', params['ttl']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document(self, token, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API  # noqa: E501

        Retrieves metadata for a document from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to retrieve (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_with_http_info(token, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_with_http_info(token, document_id, **kwargs)  # noqa: E501
            return data

    def get_document_with_http_info(self, token, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API  # noqa: E501

        Retrieves metadata for a document from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_with_http_info(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to retrieve (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `get_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document_contents(self, token, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API  # noqa: E501

        Retrieves a document's binary content from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_contents(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to retrieve (required)
        :param int max_size: Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension
        :param int jpeg_compression: JPEG compression rate, in percent (only applicable for documents of type image)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_contents_with_http_info(token, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_contents_with_http_info(token, document_id, **kwargs)  # noqa: E501
            return data

    def get_document_contents_with_http_info(self, token, document_id, **kwargs):  # noqa: E501
        """Retrieves a document from Leia API  # noqa: E501

        Retrieves a document's binary content from Leia API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_contents_with_http_info(token, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document to retrieve (required)
        :param int max_size: Restrict the size of the image to get (only applicable for documents of type image). The largest dimension of the image will be capped to this dimension
        :param int jpeg_compression: JPEG compression rate, in percent (only applicable for documents of type image)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'max_size', 'jpeg_compression']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_contents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_document_contents`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `get_document_contents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []
        if 'max_size' in params:
            query_params.append(('max_size', params['max_size']))  # noqa: E501
        if 'jpeg_compression' in params:
            query_params.append(('jpeg_compression', params['jpeg_compression']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_id}/file_contents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_documents(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API as JSON metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_documents(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id the document to retrieve
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param str tag_result: Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result
        :param str sort: If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :param int offset: Number of the first document to send (pagination)
        :param int limit: Maximum number of documents to send (pagination)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_documents_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_documents_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_documents_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API as JSON metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_documents_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id the document to retrieve
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param str tag_result: Atomically adds a tag to all retrieved values if specified. The added tag will not be returned in the result
        :param str sort: If specified, sorts the documents by a list of existing parameters separated by commas. Can be 'application_id', 'filename', 'extension', 'mime_type', 'original_id', 'page', 'creation_time'. Sorts in ascending order by default. If a parameter is preceded by '-', it is sorted in descending order.
        :param int offset: Number of the first document to send (pagination)
        :param int limit: Maximum number of documents to send (pagination)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'filename', 'extension', 'mime_type', 'original_id', 'tags', 'created_after', 'created_before', 'tag_result', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_documents`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'document_id' in params:
            query_params.append(('document_id', params['document_id']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'mime_type' in params:
            query_params.append(('mime_type', params['mime_type']))  # noqa: E501
        if 'original_id' in params:
            query_params.append(('original_id', params['original_id']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'tag_result' in params:
            query_params.append(('tag_result', params['tag_result']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Document]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_documents_tags(self, token, **kwargs):  # noqa: E501
        """Retrieves documents' tags from Leia API  # noqa: E501

        Retrieves tags from documents that the application can access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_documents_tags(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_documents_tags_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_documents_tags_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_documents_tags_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves documents' tags from Leia API  # noqa: E501

        Retrieves tags from documents that the application can access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_documents_tags_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_documents_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_documents_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/tag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_documents_zip(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API in a zip file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_documents_zip(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id the document to retrieve
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_documents_zip_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_documents_zip_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_documents_zip_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieves documents from Leia API (paginated)  # noqa: E501

        Retrieves documents which matches the query from Leia API in a zip file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_documents_zip_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id the document to retrieve
        :param str filename: The file name of the documents to retrieve
        :param str extension: The extension of the documents to retrieve
        :param str mime_type: Filters by MIME type
        :param str original_id: Filters by original id
        :param list[str] tags: If specified, filters the documents by tag
        :param datetime created_after: If specified, keeps only documents created after given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :param datetime created_before: If specified, keeps only documents created before given UTC timestamp (ISO 8601 format : yyyy-MM-ddThh:mm:ss)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'filename', 'extension', 'mime_type', 'original_id', 'tags', 'created_after', 'created_before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_documents_zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_documents_zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'document_id' in params:
            query_params.append(('document_id', params['document_id']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'extension' in params:
            query_params.append(('extension', params['extension']))  # noqa: E501
        if 'mime_type' in params:
            query_params.append(('mime_type', params['mime_type']))  # noqa: E501
        if 'original_id' in params:
            query_params.append(('original_id', params['original_id']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
            collection_formats['tags'] = 'multi'  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tag_document(self, token, document_id, tag, **kwargs):  # noqa: E501
        """Tags a document  # noqa: E501

        Tags a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tag_document(token, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to add to the document (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tag_document_with_http_info(token, document_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.tag_document_with_http_info(token, document_id, tag, **kwargs)  # noqa: E501
            return data

    def tag_document_with_http_info(self, token, document_id, tag, **kwargs):  # noqa: E501
        """Tags a document  # noqa: E501

        Tags a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tag_document_with_http_info(token, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to add to the document (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `tag_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `tag_document`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `tag_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_id}/tag/{tag}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transform_document_async(self, token, document_ids, output_type, **kwargs):  # noqa: E501
        """Asynchronously converts a document within Leia API  # noqa: E501

        Asynchronously transforms a document from its current type to the output_type. May generate multiple new documents (for example converting a PDF to image will generate one new image document for each page of the PDF). Returns a Job, that will have to be polled to get the result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transform_document_async(token, document_ids, output_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param list[str] document_ids: Comma separated list of document ids to process (required)
        :param TransformTypes output_type: The output type. May be:   * image (Extract any image from a PDF or a video)     * extract one image for each page in a PDF file     * extract one image for each frame in a video. By default only the first frame is returned, use \"image_slice\" in transform_params to specify any other frame range, view the \"page_range\" parameter for syntax of this option, use \"output_quality\" in transform_params to specify the quality of the images generated (between 1 and 100, default: 75)   * text (Use OCR on an image to get convert it to text)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params))  (required)
        :param TransformBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str input_tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :param str output_tag: The tag to add to the documents resulting from the transformation
        :param str execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :param str page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example 2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object transform_params: Free form parameters for the transformation
        :param bool block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.transform_document_async_with_http_info(token, document_ids, output_type, **kwargs)  # noqa: E501
        else:
            (data) = self.transform_document_async_with_http_info(token, document_ids, output_type, **kwargs)  # noqa: E501
            return data

    def transform_document_async_with_http_info(self, token, document_ids, output_type, **kwargs):  # noqa: E501
        """Asynchronously converts a document within Leia API  # noqa: E501

        Asynchronously transforms a document from its current type to the output_type. May generate multiple new documents (for example converting a PDF to image will generate one new image document for each page of the PDF). Returns a Job, that will have to be polled to get the result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transform_document_async_with_http_info(token, document_ids, output_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param list[str] document_ids: Comma separated list of document ids to process (required)
        :param TransformTypes output_type: The output type. May be:   * image (Extract any image from a PDF or a video)     * extract one image for each page in a PDF file     * extract one image for each frame in a video. By default only the first frame is returned, use \"image_slice\" in transform_params to specify any other frame range, view the \"page_range\" parameter for syntax of this option, use \"output_quality\" in transform_params to specify the quality of the images generated (between 1 and 100, default: 75)   * text (Use OCR on an image to get convert it to text)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * text_tree (text in the form of a JSON tree with information about text blocks and their position in the document)     * To use Google Vision OCR instead of normal LEIA OCR, add \"use_google_vision\":true in transform_params   * autorotate (Rotates an image that contains text so that it is in readable orientation)   * trim (Trims white space around a document)   * merge (Merge multiple text documents into a single one with a carriage return '\\n' between them)   * split (Splits a text document into chunks of 1000 words and replaces all spacing characters by single spaces (this number can be changed by setting split_size to another value in transform_params))  (required)
        :param TransformBody body: All the previous query parameters can also be passed as JSON in the body of the request
        :param str input_tag: The tag of the documents to process. If tag is present, document_ids should contain a single value, and the documents processed will be those where original_id=document_ids[0] and that contain the specified tag
        :param str output_tag: The tag to add to the documents resulting from the transformation
        :param str execute_after_id: The id of a job that must be in PROCESSED status before this one can be started (used to chain jobs even before the first ones are terminated). If the referenced job becomes FAILED or is CANCELED, this one will fail
        :param str page_range: The pages that should be used in previous job to process this one. Can only be used if execute_after_id is not null. Pages are indexed from 0. Syntax is the same as Python slices syntax (https://docs.python.org/3/whatsnew/2.3.html#extended-slices). Examples :   * Single positive integer : keep only this page (example 4 will keep only page 5 (Remember, pages are indexed from 0))   * Single negative integer : keep only this page, but starting from the end (example -4 will keep only page 7 if there are 10 total pages)   * Range (x:y) : keep only this range of pages (Including x but excluding y, indexed from 0)     Examples       * 2: will keep all pages starting from page 3       * :5 will keep only pages 1 to 5       * 2:5 will keep only pages 3, 4 and 5       * -4: will keep only pages 7 to 10 if there are 10 total pages)       * :-2 will keep only pages 1 to 8 if there are 10 total pages)       * -4:-2 will keep only pages 7 and 8 if there are 10 total pages)   * Stride (::w) : Keep 1 page every w pages starting at the first one (example 2 will keep only odd pages)   * Range and stride (x:y:w) : Keep 1 page every w pages within range (x:y) (example 1::2 will keep only even pages) You can use multiple ranges of page at once, comma separated (For example, 0,2:5,-2:-1 keeps the 1st page, plus pages 3->5, plus the second to last page) 
        :param str callback_url: Callback URL that should be called when the job becomes PROCESSED/FAILED/CANCELED. This URL will be called with a HTTP POST method, and the Job object as the payload. Callback server must answer with either a 200 or 204 HTTP response, to acknowledge the callback. Any other response code will be considered as a failure to call the callback.
        :param object transform_params: Free form parameters for the transformation
        :param bool block_processing: If true, blocks processing on the job until /job/{id}/start is called. Default is false
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_ids', 'output_type', 'body', 'input_tag', 'output_tag', 'execute_after_id', 'page_range', 'callback_url', 'transform_params', 'block_processing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transform_document_async" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `transform_document_async`")  # noqa: E501
        # verify the required parameter 'document_ids' is set
        if ('document_ids' not in params or
                params['document_ids'] is None):
            raise ValueError("Missing the required parameter `document_ids` when calling `transform_document_async`")  # noqa: E501
        # verify the required parameter 'output_type' is set
        if ('output_type' not in params or
                params['output_type'] is None):
            raise ValueError("Missing the required parameter `output_type` when calling `transform_document_async`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_ids' in params:
            path_params['document_ids'] = params['document_ids']  # noqa: E501
            collection_formats['document_ids'] = 'multi'  # noqa: E501
        if 'output_type' in params:
            path_params['output_type'] = params['output_type']  # noqa: E501

        query_params = []
        if 'input_tag' in params:
            query_params.append(('input_tag', params['input_tag']))  # noqa: E501
        if 'output_tag' in params:
            query_params.append(('output_tag', params['output_tag']))  # noqa: E501
        if 'execute_after_id' in params:
            query_params.append(('execute_after_id', params['execute_after_id']))  # noqa: E501
        if 'page_range' in params:
            query_params.append(('page_range', params['page_range']))  # noqa: E501
        if 'callback_url' in params:
            query_params.append(('callback_url', params['callback_url']))  # noqa: E501
        if 'transform_params' in params:
            query_params.append(('transform_params', params['transform_params']))  # noqa: E501
        if 'block_processing' in params:
            query_params.append(('block_processing', params['block_processing']))  # noqa: E501

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_ids}/transform/{output_type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def untag_document(self, token, document_id, tag, **kwargs):  # noqa: E501
        """Untags an document  # noqa: E501

        Untags a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.untag_document(token, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to delete from the document (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.untag_document_with_http_info(token, document_id, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.untag_document_with_http_info(token, document_id, tag, **kwargs)  # noqa: E501
            return data

    def untag_document_with_http_info(self, token, document_id, tag, **kwargs):  # noqa: E501
        """Untags an document  # noqa: E501

        Untags a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.untag_document_with_http_info(token, document_id, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: The login token obtained via GET /login/{api_key} (required)
        :param str document_id: The id of the document (required)
        :param str tag: The tag to delete from the document (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'document_id', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method untag_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `untag_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `untag_document`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `untag_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}
        if 'token' in params:
            header_params['token'] = params['token']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/document/{document_id}/tag/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
