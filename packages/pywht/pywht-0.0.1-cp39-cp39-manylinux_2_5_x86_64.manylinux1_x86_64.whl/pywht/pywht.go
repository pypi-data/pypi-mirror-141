/*
cgo stubs for package pywht.
File is generated by gopy. Do not edit.
gopy pkg -vm=python3 -output=out -name=pywht github.com/rudderlabs/wht-core-lib/wht
*/

package main

/*

#cgo CFLAGS: -I/usr/include/python3.9 -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -L/usr/lib -lpython3.9 -lcrypt -lpthread -ldl  -lutil -lm -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"

	pongo2 "github.com/flosch/pongo2/v5"
	"github.com/rudderlabs/wht-core-lib/wht"
	"github.com/rudderlabs/wht-core-lib/wht/base"
	"github.com/rudderlabs/wht-core-lib/wht/features"
	"github.com/rudderlabs/wht-core-lib/wht/identity"
	"github.com/rudderlabs/wht-core-lib/wht/sources"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// --- generated code for package: pywht below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *pongo2.Options
func ptrFromHandle_Ptr_pongo2_Options(h CGoHandle) *pongo2.Options {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pongo2.Options")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pongo2.Options{})).(*pongo2.Options)
}
func handleFromPtr_Ptr_pongo2_Options(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pongo2.Options", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for non-pointer handles for type: pongo2.Options
func ptrFromHandle_pongo2_Options(h CGoHandle) *pongo2.Options {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pongo2.Options")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pongo2.Options{})).(*pongo2.Options)
}
func handleFromPtr_pongo2_Options(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pongo2.Options", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: wht ---

// ---- Types ---

// Converters for pointer handles for type: *wht.ModeRefBuildSpec
func ptrFromHandle_Ptr_wht_ModeRefBuildSpec(h CGoHandle) *wht.ModeRefBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*wht.ModeRefBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ModeRefBuildSpec{})).(*wht.ModeRefBuildSpec)
}
func handleFromPtr_Ptr_wht_ModeRefBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*wht.ModeRefBuildSpec", p))
}

// Converters for pointer handles for type: *wht.ProjectFileSpec
func ptrFromHandle_Ptr_wht_ProjectFileSpec(h CGoHandle) *wht.ProjectFileSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*wht.ProjectFileSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ProjectFileSpec{})).(*wht.ProjectFileSpec)
}
func handleFromPtr_Ptr_wht_ProjectFileSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*wht.ProjectFileSpec", p))
}

// Converters for pointer handles for type: *wht.ResourceDeclSpec
func ptrFromHandle_Ptr_wht_ResourceDeclSpec(h CGoHandle) *wht.ResourceDeclSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*wht.ResourceDeclSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ResourceDeclSpec{})).(*wht.ResourceDeclSpec)
}
func handleFromPtr_Ptr_wht_ResourceDeclSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*wht.ResourceDeclSpec", p))
}

// Converters for pointer handles for type: *wht.ResourceFileSpec
func ptrFromHandle_Ptr_wht_ResourceFileSpec(h CGoHandle) *wht.ResourceFileSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*wht.ResourceFileSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ResourceFileSpec{})).(*wht.ResourceFileSpec)
}
func handleFromPtr_Ptr_wht_ResourceFileSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*wht.ResourceFileSpec", p))
}

// Converters for pointer handles for type: *wht.WhtProject
func ptrFromHandle_Ptr_wht_WhtProject(h CGoHandle) *wht.WhtProject {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*wht.WhtProject")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.WhtProject{})).(*wht.WhtProject)
}
func handleFromPtr_Ptr_wht_WhtProject(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*wht.WhtProject", p))
}

// Converters for implicit pointer handles for type: []wht.ResourceDeclSpec
func ptrFromHandle_Slice_wht_ResourceDeclSpec(h CGoHandle) *[]wht.ResourceDeclSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]wht.ResourceDeclSpec")
	if p == nil {
		return nil
	}
	return p.(*[]wht.ResourceDeclSpec)
}
func deptrFromHandle_Slice_wht_ResourceDeclSpec(h CGoHandle) []wht.ResourceDeclSpec {
	p := ptrFromHandle_Slice_wht_ResourceDeclSpec(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_wht_ResourceDeclSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]wht.ResourceDeclSpec", p))
}

// --- wrapping slice: []wht.ResourceDeclSpec ---
//export Slice_wht_ResourceDeclSpec_CTor
func Slice_wht_ResourceDeclSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_wht_ResourceDeclSpec(&[]wht.ResourceDeclSpec{}))
}

//export Slice_wht_ResourceDeclSpec_len
func Slice_wht_ResourceDeclSpec_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_wht_ResourceDeclSpec(handle))
}

//export Slice_wht_ResourceDeclSpec_elem
func Slice_wht_ResourceDeclSpec_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_wht_ResourceDeclSpec(handle)
	return handleFromPtr_wht_ResourceDeclSpec(&(s[_idx]))
}

//export Slice_wht_ResourceDeclSpec_subslice
func Slice_wht_ResourceDeclSpec_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_wht_ResourceDeclSpec(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_wht_ResourceDeclSpec(&ss))
}

//export Slice_wht_ResourceDeclSpec_set
func Slice_wht_ResourceDeclSpec_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_wht_ResourceDeclSpec(handle)
	s[_idx] = *ptrFromHandle_wht_ResourceDeclSpec(_vl)
}

//export Slice_wht_ResourceDeclSpec_append
func Slice_wht_ResourceDeclSpec_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_wht_ResourceDeclSpec(handle)
	*s = append(*s, *ptrFromHandle_wht_ResourceDeclSpec(_vl))
}

// Converters for non-pointer handles for type: wht.ModeRefBuildSpec
func ptrFromHandle_wht_ModeRefBuildSpec(h CGoHandle) *wht.ModeRefBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "wht.ModeRefBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ModeRefBuildSpec{})).(*wht.ModeRefBuildSpec)
}
func handleFromPtr_wht_ModeRefBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("wht.ModeRefBuildSpec", p))
}

// Converters for non-pointer handles for type: wht.ProjectFileSpec
func ptrFromHandle_wht_ProjectFileSpec(h CGoHandle) *wht.ProjectFileSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "wht.ProjectFileSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ProjectFileSpec{})).(*wht.ProjectFileSpec)
}
func handleFromPtr_wht_ProjectFileSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("wht.ProjectFileSpec", p))
}

// Converters for non-pointer handles for type: wht.ResourceDeclSpec
func ptrFromHandle_wht_ResourceDeclSpec(h CGoHandle) *wht.ResourceDeclSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "wht.ResourceDeclSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ResourceDeclSpec{})).(*wht.ResourceDeclSpec)
}
func handleFromPtr_wht_ResourceDeclSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("wht.ResourceDeclSpec", p))
}

// Converters for non-pointer handles for type: wht.ResourceFileSpec
func ptrFromHandle_wht_ResourceFileSpec(h CGoHandle) *wht.ResourceFileSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "wht.ResourceFileSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.ResourceFileSpec{})).(*wht.ResourceFileSpec)
}
func handleFromPtr_wht_ResourceFileSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("wht.ResourceFileSpec", p))
}

// Converters for non-pointer handles for type: wht.WhtProject
func ptrFromHandle_wht_WhtProject(h CGoHandle) *wht.WhtProject {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "wht.WhtProject")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(wht.WhtProject{})).(*wht.WhtProject)
}
func handleFromPtr_wht_WhtProject(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("wht.WhtProject", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: wht.ResourceFileSpec ---
//export wht_ResourceFileSpec_CTor
func wht_ResourceFileSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_wht_ResourceFileSpec(&wht.ResourceFileSpec{}))
}

//export wht_ResourceFileSpec_Resources_Get
func wht_ResourceFileSpec_Resources_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_wht_ResourceFileSpec(handle)
	return handleFromPtr_Slice_wht_ResourceDeclSpec(&op.Resources)
}

//export wht_ResourceFileSpec_Resources_Set
func wht_ResourceFileSpec_Resources_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_wht_ResourceFileSpec(handle)
	op.Resources = deptrFromHandle_Slice_wht_ResourceDeclSpec(val)
}

// --- wrapping struct: wht.WhtProject ---
//export wht_WhtProject_CTor
func wht_WhtProject_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_wht_WhtProject(&wht.WhtProject{}))
}

//export wht_WhtProject_Compile
func wht_WhtProject_Compile(_handle CGoHandle, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*wht.WhtProject")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(wht.WhtProject{})).(*wht.WhtProject).Compile()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(wht.WhtProject{})).(*wht.WhtProject).Compile()
	}
}

// --- wrapping struct: wht.ModeRefBuildSpec ---
//export wht_ModeRefBuildSpec_CTor
func wht_ModeRefBuildSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_wht_ModeRefBuildSpec(&wht.ModeRefBuildSpec{}))
}

// --- wrapping struct: wht.ProjectFileSpec ---
//export wht_ProjectFileSpec_CTor
func wht_ProjectFileSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_wht_ProjectFileSpec(&wht.ProjectFileSpec{}))
}

// --- wrapping struct: wht.ResourceDeclSpec ---
//export wht_ResourceDeclSpec_CTor
func wht_ResourceDeclSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_wht_ResourceDeclSpec(&wht.ResourceDeclSpec{}))
}

//export wht_ResourceDeclSpec_ResourceType_Get
func wht_ResourceDeclSpec_ResourceType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_wht_ResourceDeclSpec(handle)
	return C.CString(op.ResourceType)
}

//export wht_ResourceDeclSpec_ResourceType_Set
func wht_ResourceDeclSpec_ResourceType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_wht_ResourceDeclSpec(handle)
	op.ResourceType = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export wht_LoadProject
func wht_LoadProject(projectFolder *C.char) CGoHandle {
	cret := wht.LoadProject(C.GoString(projectFolder))

	return handleFromPtr_wht_WhtProject(&cret)
}

// ---- Functions ---

// ---- Package: base ---

// ---- Types ---

// Converters for pointer handles for type: *base.BaseWhtModel
func ptrFromHandle_Ptr_base_BaseWhtModel(h CGoHandle) *base.BaseWhtModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.BaseWhtModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.BaseWhtModel{})).(*base.BaseWhtModel)
}
func handleFromPtr_Ptr_base_BaseWhtModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.BaseWhtModel", p))
}

// Converters for pointer handles for type: *base.SqlTemplate
func ptrFromHandle_Ptr_base_SqlTemplate(h CGoHandle) *base.SqlTemplate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.SqlTemplate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.SqlTemplate{})).(*base.SqlTemplate)
}
func handleFromPtr_Ptr_base_SqlTemplate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.SqlTemplate", p))
}

// Converters for pointer handles for type: *base.WhtBuildSpec
func ptrFromHandle_Ptr_base_WhtBuildSpec(h CGoHandle) *base.WhtBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.WhtBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtBuildSpec{})).(*base.WhtBuildSpec)
}
func handleFromPtr_Ptr_base_WhtBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.WhtBuildSpec", p))
}

// Converters for pointer handles for type: *base.WhtContext
func ptrFromHandle_Ptr_base_WhtContext(h CGoHandle) *base.WhtContext {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.WhtContext")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtContext{})).(*base.WhtContext)
}
func handleFromPtr_Ptr_base_WhtContext(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.WhtContext", p))
}

// Converters for pointer handles for type: *base.WhtMaterial
func ptrFromHandle_Ptr_base_WhtMaterial(h CGoHandle) *base.WhtMaterial {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.WhtMaterial")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtMaterial{})).(*base.WhtMaterial)
}
func handleFromPtr_Ptr_base_WhtMaterial(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.WhtMaterial", p))
}

// Converters for pointer handles for type: *base.WhtModel
func ptrFromHandle_Ptr_base_WhtModel(h CGoHandle) *base.WhtModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.WhtModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtModel{})).(*base.WhtModel)
}
func handleFromPtr_Ptr_base_WhtModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.WhtModel", p))
}

// Converters for pointer handles for type: *base.WhtModelRef
func ptrFromHandle_Ptr_base_WhtModelRef(h CGoHandle) *base.WhtModelRef {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*base.WhtModelRef")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtModelRef{})).(*base.WhtModelRef)
}
func handleFromPtr_Ptr_base_WhtModelRef(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*base.WhtModelRef", p))
}

// Converters for implicit pointer handles for type: []base.WhtModel
func ptrFromHandle_Slice_base_WhtModel(h CGoHandle) *[]base.WhtModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]base.WhtModel")
	if p == nil {
		return nil
	}
	return p.(*[]base.WhtModel)
}
func deptrFromHandle_Slice_base_WhtModel(h CGoHandle) []base.WhtModel {
	p := ptrFromHandle_Slice_base_WhtModel(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_base_WhtModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]base.WhtModel", p))
}

// --- wrapping slice: []base.WhtModel ---
//export Slice_base_WhtModel_CTor
func Slice_base_WhtModel_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_base_WhtModel(&[]base.WhtModel{}))
}

//export Slice_base_WhtModel_len
func Slice_base_WhtModel_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_base_WhtModel(handle))
}

//export Slice_base_WhtModel_elem
func Slice_base_WhtModel_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_base_WhtModel(handle)
	return handleFromPtr_base_WhtModel(&(s[_idx]))
}

//export Slice_base_WhtModel_subslice
func Slice_base_WhtModel_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_base_WhtModel(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_base_WhtModel(&ss))
}

//export Slice_base_WhtModel_set
func Slice_base_WhtModel_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_base_WhtModel(handle)
	s[_idx] = *ptrFromHandle_base_WhtModel(_vl)
}

//export Slice_base_WhtModel_append
func Slice_base_WhtModel_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_base_WhtModel(handle)
	*s = append(*s, *ptrFromHandle_base_WhtModel(_vl))
}

// Converters for non-pointer handles for type: base.BaseWhtModel
func ptrFromHandle_base_BaseWhtModel(h CGoHandle) *base.BaseWhtModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.BaseWhtModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.BaseWhtModel{})).(*base.BaseWhtModel)
}
func handleFromPtr_base_BaseWhtModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.BaseWhtModel", p))
}

// Converters for pointer handles for type: base.IWhtBuildSpec
func ptrFromHandle_base_IWhtBuildSpec(h CGoHandle) base.IWhtBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.IWhtBuildSpec")
	if p == nil {
		return nil
	}
	return p.(base.IWhtBuildSpec)
}
func handleFromPtr_base_IWhtBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.IWhtBuildSpec", p))
}

// Converters for pointer handles for type: base.IWhtModel
func ptrFromHandle_base_IWhtModel(h CGoHandle) base.IWhtModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.IWhtModel")
	if p == nil {
		return nil
	}
	return p.(base.IWhtModel)
}
func handleFromPtr_base_IWhtModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.IWhtModel", p))
}

// Converters for non-pointer handles for type: base.SqlTemplate
func ptrFromHandle_base_SqlTemplate(h CGoHandle) *base.SqlTemplate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.SqlTemplate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.SqlTemplate{})).(*base.SqlTemplate)
}
func handleFromPtr_base_SqlTemplate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.SqlTemplate", p))
}

// Converters for non-pointer handles for type: base.WhtBuildSpec
func ptrFromHandle_base_WhtBuildSpec(h CGoHandle) *base.WhtBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.WhtBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtBuildSpec{})).(*base.WhtBuildSpec)
}
func handleFromPtr_base_WhtBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.WhtBuildSpec", p))
}

// Converters for non-pointer handles for type: base.WhtContext
func ptrFromHandle_base_WhtContext(h CGoHandle) *base.WhtContext {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.WhtContext")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtContext{})).(*base.WhtContext)
}
func handleFromPtr_base_WhtContext(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.WhtContext", p))
}

// Converters for non-pointer handles for type: base.WhtMaterial
func ptrFromHandle_base_WhtMaterial(h CGoHandle) *base.WhtMaterial {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.WhtMaterial")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtMaterial{})).(*base.WhtMaterial)
}
func handleFromPtr_base_WhtMaterial(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.WhtMaterial", p))
}

// Converters for non-pointer handles for type: base.WhtModel
func ptrFromHandle_base_WhtModel(h CGoHandle) *base.WhtModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.WhtModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtModel{})).(*base.WhtModel)
}
func handleFromPtr_base_WhtModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.WhtModel", p))
}

// Converters for non-pointer handles for type: base.WhtModelRef
func ptrFromHandle_base_WhtModelRef(h CGoHandle) *base.WhtModelRef {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "base.WhtModelRef")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(base.WhtModelRef{})).(*base.WhtModelRef)
}
func handleFromPtr_base_WhtModelRef(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("base.WhtModelRef", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export base_IWhtModel_Compile
func base_IWhtModel_Compile(_handle CGoHandle, whtContext CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "base.IWhtModel")
	if __err != nil {
		return C.CString("")
	}
	__err = vifc.(base.IWhtModel).Compile(*ptrFromHandle_base_WhtContext(whtContext))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export base_IWhtModel_GetInputs
func base_IWhtModel_GetInputs(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "base.IWhtModel")
	if __err != nil {
		return handleFromPtr_Slice_base_WhtModel(nil)
	}
	cret, __err := vifc.(base.IWhtModel).GetInputs()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_base_WhtModel(nil)
	}
	return handleFromPtr_Slice_base_WhtModel(&cret)
}

//export base_IWhtModel_GetSql
func base_IWhtModel_GetSql(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "base.IWhtModel")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := vifc.(base.IWhtModel).GetSql()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export base_IWhtModel_Run
func base_IWhtModel_Run(_handle CGoHandle, whtContext CGoHandle, seqNo C.longlong) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "base.IWhtModel")
	if __err != nil {
		return handleFromPtr_base_WhtMaterial(nil)
	}
	cret, __err := vifc.(base.IWhtModel).Run(*ptrFromHandle_base_WhtContext(whtContext), int(seqNo))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_base_WhtMaterial(nil)
	}
	return handleFromPtr_base_WhtMaterial(&cret)
}

// ---- Structs ---

// --- wrapping struct: base.BaseWhtModel ---
//export base_BaseWhtModel_CTor
func base_BaseWhtModel_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_BaseWhtModel(&base.BaseWhtModel{}))
}

// --- wrapping struct: base.SqlTemplate ---
//export base_SqlTemplate_CTor
func base_SqlTemplate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_SqlTemplate(&base.SqlTemplate{}))
}

//export base_SqlTemplate_Options_Get
func base_SqlTemplate_Options_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_base_SqlTemplate(handle)
	return handleFromPtr_Ptr_pongo2_Options(op.Options)
}

//export base_SqlTemplate_Options_Set
func base_SqlTemplate_Options_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_base_SqlTemplate(handle)
	op.Options = ptrFromHandle_Ptr_pongo2_Options(val)
}

// --- wrapping struct: base.WhtBuildSpec ---
//export base_WhtBuildSpec_CTor
func base_WhtBuildSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_WhtBuildSpec(&base.WhtBuildSpec{}))
}

// --- wrapping struct: base.WhtContext ---
//export base_WhtContext_CTor
func base_WhtContext_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_WhtContext(&base.WhtContext{}))
}

// --- wrapping struct: base.WhtMaterial ---
//export base_WhtMaterial_CTor
func base_WhtMaterial_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_WhtMaterial(&base.WhtMaterial{}))
}

//export base_WhtMaterial_Model_Get
func base_WhtMaterial_Model_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_base_WhtMaterial(handle)
	return handleFromPtr_base_IWhtModel(op.Model)
}

//export base_WhtMaterial_Model_Set
func base_WhtMaterial_Model_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_base_WhtMaterial(handle)
	op.Model = ptrFromHandle_base_IWhtModel(val)
}

//export base_WhtMaterial_Name_Get
func base_WhtMaterial_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_base_WhtMaterial(handle)
	return C.CString(op.Name)
}

//export base_WhtMaterial_Name_Set
func base_WhtMaterial_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_base_WhtMaterial(handle)
	op.Name = C.GoString(val)
}

//export base_WhtMaterial_IWhtContext_Get
func base_WhtMaterial_IWhtContext_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_base_WhtMaterial(handle)
	return handleFromPtr_context_Context(op.IWhtContext)
}

//export base_WhtMaterial_IWhtContext_Set
func base_WhtMaterial_IWhtContext_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_base_WhtMaterial(handle)
	op.IWhtContext = ptrFromHandle_context_Context(val)
}

//export base_WhtMaterial_SeqNo_Get
func base_WhtMaterial_SeqNo_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_base_WhtMaterial(handle)
	return C.longlong(op.SeqNo)
}

//export base_WhtMaterial_SeqNo_Set
func base_WhtMaterial_SeqNo_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_base_WhtMaterial(handle)
	op.SeqNo = int(val)
}

// --- wrapping struct: base.WhtModel ---
//export base_WhtModel_CTor
func base_WhtModel_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_WhtModel(&base.WhtModel{}))
}

// --- wrapping struct: base.WhtModelRef ---
//export base_WhtModelRef_CTor
func base_WhtModelRef_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_base_WhtModelRef(&base.WhtModelRef{}))
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: features ---

// ---- Types ---

// Converters for pointer handles for type: *features.EntityFeaturesModel
func ptrFromHandle_Ptr_features_EntityFeaturesModel(h CGoHandle) *features.EntityFeaturesModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*features.EntityFeaturesModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.EntityFeaturesModel{})).(*features.EntityFeaturesModel)
}
func handleFromPtr_Ptr_features_EntityFeaturesModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*features.EntityFeaturesModel", p))
}

// Converters for pointer handles for type: *features.FeatureIdentifierDeclaration
func ptrFromHandle_Ptr_features_FeatureIdentifierDeclaration(h CGoHandle) *features.FeatureIdentifierDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*features.FeatureIdentifierDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.FeatureIdentifierDeclaration{})).(*features.FeatureIdentifierDeclaration)
}
func handleFromPtr_Ptr_features_FeatureIdentifierDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*features.FeatureIdentifierDeclaration", p))
}

// Converters for pointer handles for type: *features.FeatureTableBuildSpec
func ptrFromHandle_Ptr_features_FeatureTableBuildSpec(h CGoHandle) *features.FeatureTableBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*features.FeatureTableBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.FeatureTableBuildSpec{})).(*features.FeatureTableBuildSpec)
}
func handleFromPtr_Ptr_features_FeatureTableBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*features.FeatureTableBuildSpec", p))
}

// Converters for pointer handles for type: *features.FeatureVarDeclaration
func ptrFromHandle_Ptr_features_FeatureVarDeclaration(h CGoHandle) *features.FeatureVarDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*features.FeatureVarDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.FeatureVarDeclaration{})).(*features.FeatureVarDeclaration)
}
func handleFromPtr_Ptr_features_FeatureVarDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*features.FeatureVarDeclaration", p))
}

// Converters for pointer handles for type: *features.MacroDeclaration
func ptrFromHandle_Ptr_features_MacroDeclaration(h CGoHandle) *features.MacroDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*features.MacroDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.MacroDeclaration{})).(*features.MacroDeclaration)
}
func handleFromPtr_Ptr_features_MacroDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*features.MacroDeclaration", p))
}

// Converters for pointer handles for type: *features.TableVarDeclaration
func ptrFromHandle_Ptr_features_TableVarDeclaration(h CGoHandle) *features.TableVarDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*features.TableVarDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.TableVarDeclaration{})).(*features.TableVarDeclaration)
}
func handleFromPtr_Ptr_features_TableVarDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*features.TableVarDeclaration", p))
}

// Converters for implicit pointer handles for type: []features.FeatureIdentifierDeclaration
func ptrFromHandle_Slice_features_FeatureIdentifierDeclaration(h CGoHandle) *[]features.FeatureIdentifierDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]features.FeatureIdentifierDeclaration")
	if p == nil {
		return nil
	}
	return p.(*[]features.FeatureIdentifierDeclaration)
}
func deptrFromHandle_Slice_features_FeatureIdentifierDeclaration(h CGoHandle) []features.FeatureIdentifierDeclaration {
	p := ptrFromHandle_Slice_features_FeatureIdentifierDeclaration(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_features_FeatureIdentifierDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]features.FeatureIdentifierDeclaration", p))
}

// --- wrapping slice: []features.FeatureIdentifierDeclaration ---
//export Slice_features_FeatureIdentifierDeclaration_CTor
func Slice_features_FeatureIdentifierDeclaration_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_features_FeatureIdentifierDeclaration(&[]features.FeatureIdentifierDeclaration{}))
}

//export Slice_features_FeatureIdentifierDeclaration_len
func Slice_features_FeatureIdentifierDeclaration_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_features_FeatureIdentifierDeclaration(handle))
}

//export Slice_features_FeatureIdentifierDeclaration_elem
func Slice_features_FeatureIdentifierDeclaration_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_features_FeatureIdentifierDeclaration(handle)
	return handleFromPtr_features_FeatureIdentifierDeclaration(&(s[_idx]))
}

//export Slice_features_FeatureIdentifierDeclaration_subslice
func Slice_features_FeatureIdentifierDeclaration_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_features_FeatureIdentifierDeclaration(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_features_FeatureIdentifierDeclaration(&ss))
}

//export Slice_features_FeatureIdentifierDeclaration_set
func Slice_features_FeatureIdentifierDeclaration_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_features_FeatureIdentifierDeclaration(handle)
	s[_idx] = *ptrFromHandle_features_FeatureIdentifierDeclaration(_vl)
}

//export Slice_features_FeatureIdentifierDeclaration_append
func Slice_features_FeatureIdentifierDeclaration_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_features_FeatureIdentifierDeclaration(handle)
	*s = append(*s, *ptrFromHandle_features_FeatureIdentifierDeclaration(_vl))
}

// Converters for implicit pointer handles for type: []identity.IdEdgeSignal
func ptrFromHandle_Slice_identity_IdEdgeSignal(h CGoHandle) *[]identity.IdEdgeSignal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]identity.IdEdgeSignal")
	if p == nil {
		return nil
	}
	return p.(*[]identity.IdEdgeSignal)
}
func deptrFromHandle_Slice_identity_IdEdgeSignal(h CGoHandle) []identity.IdEdgeSignal {
	p := ptrFromHandle_Slice_identity_IdEdgeSignal(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_identity_IdEdgeSignal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]identity.IdEdgeSignal", p))
}

// --- wrapping slice: []identity.IdEdgeSignal ---
//export Slice_identity_IdEdgeSignal_CTor
func Slice_identity_IdEdgeSignal_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_identity_IdEdgeSignal(&[]identity.IdEdgeSignal{}))
}

//export Slice_identity_IdEdgeSignal_len
func Slice_identity_IdEdgeSignal_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_identity_IdEdgeSignal(handle))
}

//export Slice_identity_IdEdgeSignal_elem
func Slice_identity_IdEdgeSignal_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_identity_IdEdgeSignal(handle)
	return handleFromPtr_identity_IdEdgeSignal(&(s[_idx]))
}

//export Slice_identity_IdEdgeSignal_subslice
func Slice_identity_IdEdgeSignal_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_identity_IdEdgeSignal(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_identity_IdEdgeSignal(&ss))
}

//export Slice_identity_IdEdgeSignal_set
func Slice_identity_IdEdgeSignal_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_identity_IdEdgeSignal(handle)
	s[_idx] = *ptrFromHandle_identity_IdEdgeSignal(_vl)
}

//export Slice_identity_IdEdgeSignal_append
func Slice_identity_IdEdgeSignal_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_identity_IdEdgeSignal(handle)
	*s = append(*s, *ptrFromHandle_identity_IdEdgeSignal(_vl))
}

// Converters for implicit pointer handles for type: []identity.IdStitchingModelInput
func ptrFromHandle_Slice_identity_IdStitchingModelInput(h CGoHandle) *[]identity.IdStitchingModelInput {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]identity.IdStitchingModelInput")
	if p == nil {
		return nil
	}
	return p.(*[]identity.IdStitchingModelInput)
}
func deptrFromHandle_Slice_identity_IdStitchingModelInput(h CGoHandle) []identity.IdStitchingModelInput {
	p := ptrFromHandle_Slice_identity_IdStitchingModelInput(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_identity_IdStitchingModelInput(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]identity.IdStitchingModelInput", p))
}

// --- wrapping slice: []identity.IdStitchingModelInput ---
//export Slice_identity_IdStitchingModelInput_CTor
func Slice_identity_IdStitchingModelInput_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_identity_IdStitchingModelInput(&[]identity.IdStitchingModelInput{}))
}

//export Slice_identity_IdStitchingModelInput_len
func Slice_identity_IdStitchingModelInput_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_identity_IdStitchingModelInput(handle))
}

//export Slice_identity_IdStitchingModelInput_elem
func Slice_identity_IdStitchingModelInput_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_identity_IdStitchingModelInput(handle)
	return handleFromPtr_identity_IdStitchingModelInput(&(s[_idx]))
}

//export Slice_identity_IdStitchingModelInput_subslice
func Slice_identity_IdStitchingModelInput_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_identity_IdStitchingModelInput(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_identity_IdStitchingModelInput(&ss))
}

//export Slice_identity_IdStitchingModelInput_set
func Slice_identity_IdStitchingModelInput_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_identity_IdStitchingModelInput(handle)
	s[_idx] = *ptrFromHandle_identity_IdStitchingModelInput(_vl)
}

//export Slice_identity_IdStitchingModelInput_append
func Slice_identity_IdStitchingModelInput_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_identity_IdStitchingModelInput(handle)
	*s = append(*s, *ptrFromHandle_identity_IdStitchingModelInput(_vl))
}

// Converters for non-pointer handles for type: features.EntityFeaturesModel
func ptrFromHandle_features_EntityFeaturesModel(h CGoHandle) *features.EntityFeaturesModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "features.EntityFeaturesModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.EntityFeaturesModel{})).(*features.EntityFeaturesModel)
}
func handleFromPtr_features_EntityFeaturesModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("features.EntityFeaturesModel", p))
}

// Converters for non-pointer handles for type: features.FeatureIdentifierDeclaration
func ptrFromHandle_features_FeatureIdentifierDeclaration(h CGoHandle) *features.FeatureIdentifierDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "features.FeatureIdentifierDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.FeatureIdentifierDeclaration{})).(*features.FeatureIdentifierDeclaration)
}
func handleFromPtr_features_FeatureIdentifierDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("features.FeatureIdentifierDeclaration", p))
}

// Converters for non-pointer handles for type: features.FeatureTableBuildSpec
func ptrFromHandle_features_FeatureTableBuildSpec(h CGoHandle) *features.FeatureTableBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "features.FeatureTableBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.FeatureTableBuildSpec{})).(*features.FeatureTableBuildSpec)
}
func handleFromPtr_features_FeatureTableBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("features.FeatureTableBuildSpec", p))
}

// Converters for non-pointer handles for type: features.FeatureVarDeclaration
func ptrFromHandle_features_FeatureVarDeclaration(h CGoHandle) *features.FeatureVarDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "features.FeatureVarDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.FeatureVarDeclaration{})).(*features.FeatureVarDeclaration)
}
func handleFromPtr_features_FeatureVarDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("features.FeatureVarDeclaration", p))
}

// Converters for non-pointer handles for type: features.MacroDeclaration
func ptrFromHandle_features_MacroDeclaration(h CGoHandle) *features.MacroDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "features.MacroDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.MacroDeclaration{})).(*features.MacroDeclaration)
}
func handleFromPtr_features_MacroDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("features.MacroDeclaration", p))
}

// Converters for non-pointer handles for type: features.TableVarDeclaration
func ptrFromHandle_features_TableVarDeclaration(h CGoHandle) *features.TableVarDeclaration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "features.TableVarDeclaration")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(features.TableVarDeclaration{})).(*features.TableVarDeclaration)
}
func handleFromPtr_features_TableVarDeclaration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("features.TableVarDeclaration", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: features.MacroDeclaration ---
//export features_MacroDeclaration_CTor
func features_MacroDeclaration_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_features_MacroDeclaration(&features.MacroDeclaration{}))
}

//export features_MacroDeclaration_Macro_Get
func features_MacroDeclaration_Macro_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_MacroDeclaration(handle)
	return C.CString(op.Macro)
}

//export features_MacroDeclaration_Macro_Set
func features_MacroDeclaration_Macro_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_MacroDeclaration(handle)
	op.Macro = C.GoString(val)
}

//export features_MacroDeclaration_Description_Get
func features_MacroDeclaration_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_MacroDeclaration(handle)
	return C.CString(op.Description)
}

//export features_MacroDeclaration_Description_Set
func features_MacroDeclaration_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_MacroDeclaration(handle)
	op.Description = C.GoString(val)
}

//export features_MacroDeclaration_Value_Get
func features_MacroDeclaration_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_MacroDeclaration(handle)
	return C.CString(op.Value)
}

//export features_MacroDeclaration_Value_Set
func features_MacroDeclaration_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_MacroDeclaration(handle)
	op.Value = C.GoString(val)
}

// --- wrapping struct: features.TableVarDeclaration ---
//export features_TableVarDeclaration_CTor
func features_TableVarDeclaration_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_features_TableVarDeclaration(&features.TableVarDeclaration{}))
}

//export features_TableVarDeclaration_TableVar_Get
func features_TableVarDeclaration_TableVar_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	return C.CString(op.TableVar)
}

//export features_TableVarDeclaration_TableVar_Set
func features_TableVarDeclaration_TableVar_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	op.TableVar = C.GoString(val)
}

//export features_TableVarDeclaration_Description_Get
func features_TableVarDeclaration_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	return C.CString(op.Description)
}

//export features_TableVarDeclaration_Description_Set
func features_TableVarDeclaration_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	op.Description = C.GoString(val)
}

//export features_TableVarDeclaration_Filter_Get
func features_TableVarDeclaration_Filter_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	return C.CString(op.Filter)
}

//export features_TableVarDeclaration_Filter_Set
func features_TableVarDeclaration_Filter_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	op.Filter = C.GoString(val)
}

//export features_TableVarDeclaration_Value_Get
func features_TableVarDeclaration_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	return C.CString(op.Value)
}

//export features_TableVarDeclaration_Value_Set
func features_TableVarDeclaration_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_TableVarDeclaration(handle)
	op.Value = C.GoString(val)
}

// --- wrapping struct: features.EntityFeaturesModel ---
//export features_EntityFeaturesModel_CTor
func features_EntityFeaturesModel_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_features_EntityFeaturesModel(&features.EntityFeaturesModel{}))
}

//export features_EntityFeaturesModel_Inputs_Get
func features_EntityFeaturesModel_Inputs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_features_EntityFeaturesModel(handle)
	return handleFromPtr_Slice_identity_IdStitchingModelInput(&op.Inputs)
}

//export features_EntityFeaturesModel_Inputs_Set
func features_EntityFeaturesModel_Inputs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_features_EntityFeaturesModel(handle)
	op.Inputs = deptrFromHandle_Slice_identity_IdStitchingModelInput(val)
}

//export features_EntityFeaturesModel_IdStitcher_Get
func features_EntityFeaturesModel_IdStitcher_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_features_EntityFeaturesModel(handle)
	return handleFromPtr_identity_IdStitchingModel(&op.IdStitcher)
}

//export features_EntityFeaturesModel_IdStitcher_Set
func features_EntityFeaturesModel_IdStitcher_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_features_EntityFeaturesModel(handle)
	op.IdStitcher = *ptrFromHandle_identity_IdStitchingModel(val)
}

//export features_EntityFeaturesModel_Compile
func features_EntityFeaturesModel_Compile(_handle CGoHandle, whtContext CGoHandle, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*features.EntityFeaturesModel")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(features.EntityFeaturesModel{})).(*features.EntityFeaturesModel).Compile(*ptrFromHandle_base_WhtContext(whtContext))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(features.EntityFeaturesModel{})).(*features.EntityFeaturesModel).Compile(*ptrFromHandle_base_WhtContext(whtContext))
	}
}

// --- wrapping struct: features.FeatureIdentifierDeclaration ---
//export features_FeatureIdentifierDeclaration_CTor
func features_FeatureIdentifierDeclaration_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_features_FeatureIdentifierDeclaration(&features.FeatureIdentifierDeclaration{}))
}

// --- wrapping struct: features.FeatureTableBuildSpec ---
//export features_FeatureTableBuildSpec_CTor
func features_FeatureTableBuildSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_features_FeatureTableBuildSpec(&features.FeatureTableBuildSpec{}))
}

//export features_FeatureTableBuildSpec_Features_Get
func features_FeatureTableBuildSpec_Features_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_features_FeatureTableBuildSpec(handle)
	return handleFromPtr_Slice_features_FeatureIdentifierDeclaration(&op.Features)
}

//export features_FeatureTableBuildSpec_Features_Set
func features_FeatureTableBuildSpec_Features_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_features_FeatureTableBuildSpec(handle)
	op.Features = deptrFromHandle_Slice_features_FeatureIdentifierDeclaration(val)
}

// --- wrapping struct: features.FeatureVarDeclaration ---
//export features_FeatureVarDeclaration_CTor
func features_FeatureVarDeclaration_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_features_FeatureVarDeclaration(&features.FeatureVarDeclaration{}))
}

//export features_FeatureVarDeclaration_Feature_Get
func features_FeatureVarDeclaration_Feature_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_FeatureVarDeclaration(handle)
	return C.CString(op.Feature)
}

//export features_FeatureVarDeclaration_Feature_Set
func features_FeatureVarDeclaration_Feature_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_FeatureVarDeclaration(handle)
	op.Feature = C.GoString(val)
}

//export features_FeatureVarDeclaration_Description_Get
func features_FeatureVarDeclaration_Description_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_FeatureVarDeclaration(handle)
	return C.CString(op.Description)
}

//export features_FeatureVarDeclaration_Description_Set
func features_FeatureVarDeclaration_Description_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_FeatureVarDeclaration(handle)
	op.Description = C.GoString(val)
}

//export features_FeatureVarDeclaration_Value_Get
func features_FeatureVarDeclaration_Value_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_features_FeatureVarDeclaration(handle)
	return C.CString(op.Value)
}

//export features_FeatureVarDeclaration_Value_Set
func features_FeatureVarDeclaration_Value_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_features_FeatureVarDeclaration(handle)
	op.Value = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: identity ---

// ---- Types ---

// Converters for pointer handles for type: *identity.IdEdgeSignal
func ptrFromHandle_Ptr_identity_IdEdgeSignal(h CGoHandle) *identity.IdEdgeSignal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*identity.IdEdgeSignal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdEdgeSignal{})).(*identity.IdEdgeSignal)
}
func handleFromPtr_Ptr_identity_IdEdgeSignal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*identity.IdEdgeSignal", p))
}

// Converters for pointer handles for type: *identity.IdStitchingBuildSpec
func ptrFromHandle_Ptr_identity_IdStitchingBuildSpec(h CGoHandle) *identity.IdStitchingBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*identity.IdStitchingBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdStitchingBuildSpec{})).(*identity.IdStitchingBuildSpec)
}
func handleFromPtr_Ptr_identity_IdStitchingBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*identity.IdStitchingBuildSpec", p))
}

// Converters for pointer handles for type: *identity.IdStitchingModel
func ptrFromHandle_Ptr_identity_IdStitchingModel(h CGoHandle) *identity.IdStitchingModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*identity.IdStitchingModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdStitchingModel{})).(*identity.IdStitchingModel)
}
func handleFromPtr_Ptr_identity_IdStitchingModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*identity.IdStitchingModel", p))
}

// Converters for pointer handles for type: *identity.IdStitchingModelInput
func ptrFromHandle_Ptr_identity_IdStitchingModelInput(h CGoHandle) *identity.IdStitchingModelInput {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*identity.IdStitchingModelInput")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdStitchingModelInput{})).(*identity.IdStitchingModelInput)
}
func handleFromPtr_Ptr_identity_IdStitchingModelInput(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*identity.IdStitchingModelInput", p))
}

// Converters for non-pointer handles for type: identity.IdEdgeSignal
func ptrFromHandle_identity_IdEdgeSignal(h CGoHandle) *identity.IdEdgeSignal {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "identity.IdEdgeSignal")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdEdgeSignal{})).(*identity.IdEdgeSignal)
}
func handleFromPtr_identity_IdEdgeSignal(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("identity.IdEdgeSignal", p))
}

// Converters for non-pointer handles for type: identity.IdStitchingBuildSpec
func ptrFromHandle_identity_IdStitchingBuildSpec(h CGoHandle) *identity.IdStitchingBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "identity.IdStitchingBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdStitchingBuildSpec{})).(*identity.IdStitchingBuildSpec)
}
func handleFromPtr_identity_IdStitchingBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("identity.IdStitchingBuildSpec", p))
}

// Converters for non-pointer handles for type: identity.IdStitchingModel
func ptrFromHandle_identity_IdStitchingModel(h CGoHandle) *identity.IdStitchingModel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "identity.IdStitchingModel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdStitchingModel{})).(*identity.IdStitchingModel)
}
func handleFromPtr_identity_IdStitchingModel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("identity.IdStitchingModel", p))
}

// Converters for non-pointer handles for type: identity.IdStitchingModelInput
func ptrFromHandle_identity_IdStitchingModelInput(h CGoHandle) *identity.IdStitchingModelInput {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "identity.IdStitchingModelInput")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(identity.IdStitchingModelInput{})).(*identity.IdStitchingModelInput)
}
func handleFromPtr_identity_IdStitchingModelInput(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("identity.IdStitchingModelInput", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: identity.IdStitchingBuildSpec ---
//export identity_IdStitchingBuildSpec_CTor
func identity_IdStitchingBuildSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_identity_IdStitchingBuildSpec(&identity.IdStitchingBuildSpec{}))
}

// --- wrapping struct: identity.IdStitchingModel ---
//export identity_IdStitchingModel_CTor
func identity_IdStitchingModel_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_identity_IdStitchingModel(&identity.IdStitchingModel{}))
}

//export identity_IdStitchingModel_Inputs_Get
func identity_IdStitchingModel_Inputs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_identity_IdStitchingModel(handle)
	return handleFromPtr_Slice_identity_IdStitchingModelInput(&op.Inputs)
}

//export identity_IdStitchingModel_Inputs_Set
func identity_IdStitchingModel_Inputs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_identity_IdStitchingModel(handle)
	op.Inputs = deptrFromHandle_Slice_identity_IdStitchingModelInput(val)
}

//export identity_IdStitchingModel_IdEdgeSignals_Get
func identity_IdStitchingModel_IdEdgeSignals_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_identity_IdStitchingModel(handle)
	return handleFromPtr_Slice_identity_IdEdgeSignal(&op.IdEdgeSignals)
}

//export identity_IdStitchingModel_IdEdgeSignals_Set
func identity_IdStitchingModel_IdEdgeSignals_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_identity_IdStitchingModel(handle)
	op.IdEdgeSignals = deptrFromHandle_Slice_identity_IdEdgeSignal(val)
}

// --- wrapping struct: identity.IdStitchingModelInput ---
//export identity_IdStitchingModelInput_CTor
func identity_IdStitchingModelInput_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_identity_IdStitchingModelInput(&identity.IdStitchingModelInput{}))
}

//export identity_IdStitchingModelInput_Model_Get
func identity_IdStitchingModelInput_Model_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_identity_IdStitchingModelInput(handle)
	return handleFromPtr_base_IWhtModel(op.Model)
}

//export identity_IdStitchingModelInput_Model_Set
func identity_IdStitchingModelInput_Model_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_identity_IdStitchingModelInput(handle)
	op.Model = ptrFromHandle_base_IWhtModel(val)
}

//export identity_IdStitchingModelInput_IdSql_Get
func identity_IdStitchingModelInput_IdSql_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_identity_IdStitchingModelInput(handle)
	return C.CString(op.IdSql)
}

//export identity_IdStitchingModelInput_IdSql_Set
func identity_IdStitchingModelInput_IdSql_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_identity_IdStitchingModelInput(handle)
	op.IdSql = C.GoString(val)
}

// --- wrapping struct: identity.IdEdgeSignal ---
//export identity_IdEdgeSignal_CTor
func identity_IdEdgeSignal_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_identity_IdEdgeSignal(&identity.IdEdgeSignal{}))
}

//export identity_IdEdgeSignal_ModelRef_Get
func identity_IdEdgeSignal_ModelRef_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_identity_IdEdgeSignal(handle)
	return handleFromPtr_base_WhtModelRef(&op.ModelRef)
}

//export identity_IdEdgeSignal_ModelRef_Set
func identity_IdEdgeSignal_ModelRef_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_identity_IdEdgeSignal(handle)
	op.ModelRef = *ptrFromHandle_base_WhtModelRef(val)
}

//export identity_IdEdgeSignal_IdSql1_Get
func identity_IdEdgeSignal_IdSql1_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_identity_IdEdgeSignal(handle)
	return C.CString(op.IdSql1)
}

//export identity_IdEdgeSignal_IdSql1_Set
func identity_IdEdgeSignal_IdSql1_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_identity_IdEdgeSignal(handle)
	op.IdSql1 = C.GoString(val)
}

//export identity_IdEdgeSignal_IdSql2_Get
func identity_IdEdgeSignal_IdSql2_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_identity_IdEdgeSignal(handle)
	return C.CString(op.IdSql2)
}

//export identity_IdEdgeSignal_IdSql2_Set
func identity_IdEdgeSignal_IdSql2_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_identity_IdEdgeSignal(handle)
	op.IdSql2 = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: sources ---

// ---- Types ---

// Converters for pointer handles for type: *sources.ModelRefBuildSpec
func ptrFromHandle_Ptr_sources_ModelRefBuildSpec(h CGoHandle) *sources.ModelRefBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*sources.ModelRefBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(sources.ModelRefBuildSpec{})).(*sources.ModelRefBuildSpec)
}
func handleFromPtr_Ptr_sources_ModelRefBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*sources.ModelRefBuildSpec", p))
}

// Converters for pointer handles for type: *sources.ModelSourceBuildSpec
func ptrFromHandle_Ptr_sources_ModelSourceBuildSpec(h CGoHandle) *sources.ModelSourceBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*sources.ModelSourceBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(sources.ModelSourceBuildSpec{})).(*sources.ModelSourceBuildSpec)
}
func handleFromPtr_Ptr_sources_ModelSourceBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*sources.ModelSourceBuildSpec", p))
}

// Converters for non-pointer handles for type: sources.ModelRefBuildSpec
func ptrFromHandle_sources_ModelRefBuildSpec(h CGoHandle) *sources.ModelRefBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "sources.ModelRefBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(sources.ModelRefBuildSpec{})).(*sources.ModelRefBuildSpec)
}
func handleFromPtr_sources_ModelRefBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("sources.ModelRefBuildSpec", p))
}

// Converters for non-pointer handles for type: sources.ModelSourceBuildSpec
func ptrFromHandle_sources_ModelSourceBuildSpec(h CGoHandle) *sources.ModelSourceBuildSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "sources.ModelSourceBuildSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(sources.ModelSourceBuildSpec{})).(*sources.ModelSourceBuildSpec)
}
func handleFromPtr_sources_ModelSourceBuildSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("sources.ModelSourceBuildSpec", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: sources.ModelRefBuildSpec ---
//export sources_ModelRefBuildSpec_CTor
func sources_ModelRefBuildSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_sources_ModelRefBuildSpec(&sources.ModelRefBuildSpec{}))
}

// --- wrapping struct: sources.ModelSourceBuildSpec ---
//export sources_ModelSourceBuildSpec_CTor
func sources_ModelSourceBuildSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_sources_ModelSourceBuildSpec(&sources.ModelSourceBuildSpec{}))
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---
