
# python wrapper for package github.com/rudderlabs/wht-core-lib/wht/identity within overall package pywht
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg -vm=python3 -output=out -name=pywht github.com/rudderlabs/wht-core-lib/wht

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from pywht import _pywht
from pywht import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from pywht import identity
# and then refer to everything using identity. prefix
# packages imported by this package listed below:

from pywht import base
from pywht import sources
from pywht import features



# ---- Types ---


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct identity.IdStitchingBuildSpec
class IdStitchingBuildSpec(go.GoClass):
	"""IdStitching YAML is parsed using this struct.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pywht.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pywht.IncRef(self.handle)
		else:
			self.handle = _pywht.identity_IdStitchingBuildSpec_CTor()
			_pywht.IncRef(self.handle)
	def __del__(self):
		_pywht.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdStitchingBuildSpec{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdStitchingBuildSpec ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct identity.IdStitchingModel
class IdStitchingModel(base.BaseWhtModel):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pywht.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pywht.IncRef(self.handle)
		else:
			self.handle = _pywht.identity_IdStitchingModel_CTor()
			_pywht.IncRef(self.handle)
			if  1 < len(args):
				self.Inputs = args[1]
			if "Inputs" in kwargs:
				self.Inputs = kwargs["Inputs"]
			if  2 < len(args):
				self.IdEdgeSignals = args[2]
			if "IdEdgeSignals" in kwargs:
				self.IdEdgeSignals = kwargs["IdEdgeSignals"]
	def __del__(self):
		_pywht.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdStitchingModel{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdStitchingModel ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Inputs(self):
		return features.Slice_identity_IdStitchingModelInput(handle=_pywht.identity_IdStitchingModel_Inputs_Get(self.handle))
	@Inputs.setter
	def Inputs(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdStitchingModel_Inputs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IdEdgeSignals(self):
		return features.Slice_identity_IdEdgeSignal(handle=_pywht.identity_IdStitchingModel_IdEdgeSignals_Get(self.handle))
	@IdEdgeSignals.setter
	def IdEdgeSignals(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdStitchingModel_IdEdgeSignals_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct identity.IdStitchingModelInput
class IdStitchingModelInput(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pywht.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pywht.IncRef(self.handle)
		else:
			self.handle = _pywht.identity_IdStitchingModelInput_CTor()
			_pywht.IncRef(self.handle)
			if  0 < len(args):
				self.Model = args[0]
			if "Model" in kwargs:
				self.Model = kwargs["Model"]
			if  1 < len(args):
				self.IdSql = args[1]
			if "IdSql" in kwargs:
				self.IdSql = kwargs["IdSql"]
	def __del__(self):
		_pywht.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdStitchingModelInput{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdStitchingModelInput ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Model(self):
		return base.IWhtModel(handle=_pywht.identity_IdStitchingModelInput_Model_Get(self.handle))
	@Model.setter
	def Model(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdStitchingModelInput_Model_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IdSql(self):
		return _pywht.identity_IdStitchingModelInput_IdSql_Get(self.handle)
	@IdSql.setter
	def IdSql(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdStitchingModelInput_IdSql_Set(self.handle, value.handle)
		else:
			_pywht.identity_IdStitchingModelInput_IdSql_Set(self.handle, value)

# Python type for struct identity.IdEdgeSignal
class IdEdgeSignal(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_pywht.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_pywht.IncRef(self.handle)
		else:
			self.handle = _pywht.identity_IdEdgeSignal_CTor()
			_pywht.IncRef(self.handle)
			if  0 < len(args):
				self.ModelRef = args[0]
			if "ModelRef" in kwargs:
				self.ModelRef = kwargs["ModelRef"]
			if  1 < len(args):
				self.IdSql1 = args[1]
			if "IdSql1" in kwargs:
				self.IdSql1 = kwargs["IdSql1"]
			if  2 < len(args):
				self.IdSql2 = args[2]
			if "IdSql2" in kwargs:
				self.IdSql2 = kwargs["IdSql2"]
	def __del__(self):
		_pywht.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdEdgeSignal{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'identity.IdEdgeSignal ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ModelRef(self):
		return base.WhtModelRef(handle=_pywht.identity_IdEdgeSignal_ModelRef_Get(self.handle))
	@ModelRef.setter
	def ModelRef(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdEdgeSignal_ModelRef_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IdSql1(self):
		return _pywht.identity_IdEdgeSignal_IdSql1_Get(self.handle)
	@IdSql1.setter
	def IdSql1(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdEdgeSignal_IdSql1_Set(self.handle, value.handle)
		else:
			_pywht.identity_IdEdgeSignal_IdSql1_Set(self.handle, value)
	@property
	def IdSql2(self):
		return _pywht.identity_IdEdgeSignal_IdSql2_Get(self.handle)
	@IdSql2.setter
	def IdSql2(self, value):
		if isinstance(value, go.GoClass):
			_pywht.identity_IdEdgeSignal_IdSql2_Set(self.handle, value.handle)
		else:
			_pywht.identity_IdEdgeSignal_IdSql2_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---


