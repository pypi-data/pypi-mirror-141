Metadata-Version: 2.1
Name: pytest-responsemock
Version: 1.1.1
Summary: Simplified requests calls mocking for pytest
Home-page: https://github.com/idlesign/pytest-responsemock
Author: Igor `idle sign` Starikov
Author-email: idlesign@yandex.ru
License: BSD 3-Clause License
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: License :: OSI Approved :: BSD License
Classifier: Framework :: Pytest
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Testing
Requires-Python: >=3.7
Requires-Dist: pytest
Requires-Dist: responses (>=0.18.0)

pytest-responsemock
===================
https://github.com/idlesign/pytest-responsemock

|release| |lic| |coverage|

.. |release| image:: https://img.shields.io/pypi/v/pytest-responsemock.svg
    :target: https://pypi.python.org/pypi/pytest-responsemock

.. |lic| image:: https://img.shields.io/pypi/l/pytest-responsemock.svg
    :target: https://pypi.python.org/pypi/pytest-responsemock

.. |coverage| image:: https://img.shields.io/coveralls/idlesign/pytest-responsemock/master.svg
    :target: https://coveralls.io/r/idlesign/pytest-responsemock


Description
-----------

*Simplified requests calls mocking for pytest*

Provides ``response_mock`` fixture, exposing simple context manager.

Any request under that manager will be intercepted and mocked according
to one or more ``rules`` passed to the manager. If actual request won't fall
under any of given rules then an exception is raised (by default).

Rules are simple strings, of the pattern: ``HTTP_METHOD URL -> STATUS_CODE :BODY``.


Requirements
------------

* Python 3.7+


Usage
-----

When this package is installed ``response_mock`` is available for ``pytest`` test functions.

.. code-block:: python

    def for_test():
        return requests.get('http://some.domain')


    def test_me(response_mock):

        # Pass response rule as a string,
        # or many rules (to mock consequent requests) as a list of strings/bytes.
        # Use optional `bypass` argument to disable mock conditionally.

        with response_mock('GET http://some.domain -> 200 :Nice', bypass=False):

            result = for_test()

            assert result.ok
            assert result.content == b'Nice'

        # mock consequent requests
        with response_mock([
            'GET http://some.domain -> 200 :Nice',
            'GET http://other.domain -> 200 :Sweet',
        ]):
            for_test()
            requests.get('http://other.domain')


Use with ``pytest-datafixtures``:

.. code-block:: python

    def test_me(response_mock, datafix_read):

        with response_mock(f"GET http://some.domain -> 200 :{datafix_read('myresponse.html')}"):
            ...


Describe response header fields using multiline strings:

.. code-block:: python

    with response_mock(
        '''
        GET http://some.domain

        Allow: GET, HEAD
        Content-Language: ru

        -> 200 :OK
        '''
    ):
        ...

Test json response:

.. code-block:: python

    response = json.dumps({'key': 'value', 'another': 'yes'})

    with response_mock(f'POST http://some.domain -> 400 :{response}'):
        ...

To test binary response pass rule as bytes:

.. code-block:: python

    with response_mock(b'GET http://some.domain -> 200 :' + my_bytes):
        ...

Access underlying RequestsMock (from ``responses`` package) as ``mock``:

.. code-block:: python

    with response_mock('HEAD http://some.domain -> 200 :Nope') as mock:

        mock.add_passthru('http://other.domain')



