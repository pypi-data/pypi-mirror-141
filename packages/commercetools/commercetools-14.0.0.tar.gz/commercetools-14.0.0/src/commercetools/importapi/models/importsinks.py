# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import ImportResourceType

if typing.TYPE_CHECKING:
    from .common import ImportResourceType

__all__ = [
    "ImportSink",
    "ImportSinkDraft",
    "ImportSinkPagedResponse",
    "ImportSinkUpdateDraft",
]


class ImportSink(_BaseType):
    """Serves as the entry point of resources."""

    #: User-defined unique identifier for the ImportSink.
    #: Keys can only contain alphanumeric characters (a-Z, 0-9), underscores and hyphens (_, -).
    key: str
    #: The [resource type](#importresourcetype) the ImportSink is able to handle.
    #: If not present, the ImportSink is able to import all of the supported [ImportResourceTypes](#importresourcetype).
    resource_type: typing.Optional["ImportResourceType"]
    #: The version of the ImportSink.
    version: int
    #: The time when the ImportSink was created.
    created_at: datetime.datetime
    #: The last time when the ImportSink was modified.
    last_modified_at: datetime.datetime

    def __init__(
        self,
        *,
        key: str,
        resource_type: typing.Optional["ImportResourceType"] = None,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime
    ):
        self.key = key
        self.resource_type = resource_type
        self.version = version
        self.created_at = created_at
        self.last_modified_at = last_modified_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportSink":
        from ._schemas.importsinks import ImportSinkSchema

        return ImportSinkSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importsinks import ImportSinkSchema

        return ImportSinkSchema().dump(self)


class ImportSinkDraft(_BaseType):
    """The representation sent to the server when creating an [ImportSink](#importsink)."""

    #: User-defined unique identifier of the ImportSink.
    #: Keys can only contain alphanumeric characters (a-Z, 0-9), underscores and hyphens (_, -).
    key: str
    #: The [resource type](#importresourcetype) to be imported.
    #: If not given, the ImportSink is able to import all of the supported [ImportResourceTypes](#importresourcetype).
    resource_type: typing.Optional["ImportResourceType"]

    def __init__(
        self, *, key: str, resource_type: typing.Optional["ImportResourceType"] = None
    ):
        self.key = key
        self.resource_type = resource_type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportSinkDraft":
        from ._schemas.importsinks import ImportSinkDraftSchema

        return ImportSinkDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importsinks import ImportSinkDraftSchema

        return ImportSinkDraftSchema().dump(self)


class ImportSinkUpdateDraft(_BaseType):
    """The representation sent to the server when updating an [ImportSink](#importsink)."""

    #: Current version of the ImportSink.
    version: int
    #: The [resource type](#importresourcetype) to be imported.
    #: If not given, the ImportSink is able to import all of the supported [ImportResourceTypes](#importresourcetype).
    resource_type: typing.Optional["ImportResourceType"]

    def __init__(
        self,
        *,
        version: int,
        resource_type: typing.Optional["ImportResourceType"] = None
    ):
        self.version = version
        self.resource_type = resource_type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImportSinkUpdateDraft":
        from ._schemas.importsinks import ImportSinkUpdateDraftSchema

        return ImportSinkUpdateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importsinks import ImportSinkUpdateDraftSchema

        return ImportSinkUpdateDraftSchema().dump(self)


class ImportSinkPagedResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) for [ImportSinks](#importsink).
    Used as a response to a query request for [ImportSinks](#importsink).

    """

    #: The number of results requested in the query request.
    limit: int
    #: The number of elements skipped, not a page number.
    #: Supplied by the client or the server default.
    offset: int
    #: The actual number of results returned.
    count: int
    #: The total number of results matching the query.
    total: int
    #: The array of Import Sinks matching the query.
    results: typing.List["ImportSink"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: int,
        results: typing.List["ImportSink"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ImportSinkPagedResponse":
        from ._schemas.importsinks import ImportSinkPagedResponseSchema

        return ImportSinkPagedResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.importsinks import ImportSinkPagedResponseSchema

        return ImportSinkPagedResponseSchema().dump(self)
