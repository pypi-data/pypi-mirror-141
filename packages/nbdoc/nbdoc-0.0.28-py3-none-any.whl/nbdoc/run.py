# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/run.ipynb (unless otherwise specified).

__all__ = ['nbrun', 'nbupdate', 'parallel_nbupdate', 'nbdoc_update']

# Cell
from os import sys
import nbformat
from nbformat.notebooknode import NotebookNode
from nbclient.exceptions import CellExecutionError
from nbclient import NotebookClient
from nbdev.export import nbglob
from typing import Union
from fastcore.all import Path, parallel, call_parse, L

# Cell
def nbrun(fname:Union[str, Path]) -> NotebookNode:
    "Execute notebook."
    file = Path(fname)
    assert file.name.endswith('.ipynb'), f'{str(fname)} is not a notebook.'
    assert file.is_file(), f'file {str(fname)} not found.'
    print(f"running: {str(file)}")
    nb = nbformat.read(file, as_version=4)
    client = NotebookClient(nb, resources={'metadata': {'path': file.parent}})
    client.execute()
    return nb

# Cell
def nbupdate(fname:Union[str, Path]):
    "Run notebooks and update them in place."
    try:
        nb = nbrun(fname)
    except CellExecutionError as e:
        print(f'Error in {str(fname)}:\n{e}')
        return False
    print(f"finished: {str(fname)}")
    nbformat.write(nb, fname)
    return True

# Cell
def parallel_nbupdate(basedir:Union[Path,str], recursive=True, n_workers=None, pause=0.1):
    "Run all notebooks in `dir` and save them in place."
    files = L(nbglob(basedir, recursive=recursive)).filter(lambda x: not x.name.startswith('Untitled'))
    if len(files)==1:
        if n_workers is None: n_workers=0
    if sys.platform == "win32": n_workers = 0
    passed = parallel(nbupdate, files, n_workers=n_workers, pause=pause)
    if all(passed): print("All notebooks refreshed!")
    else:
        msg = "Notebook Run & Update failed on the following:\n"
        raise Exception(msg + '\n'.join([f.name for p,f in zip(passed,files) if not p]))

# Cell
@call_parse
def nbdoc_update(
    srcdir:str=None,  # A directory of notebooks to refresh recursively, can also be a filename.
    n_workers:int=None,  # Number of workers to use
    pause:float=0.5  # Pause time (in secs) between notebooks to avoid race conditions
):
    "Refresh all notebooks in `srcdir` by running them and saving them in place."
    parallel_nbupdate(basedir=srcdir,
                      recursive=True,
                      n_workers=n_workers,
                      pause=pause)