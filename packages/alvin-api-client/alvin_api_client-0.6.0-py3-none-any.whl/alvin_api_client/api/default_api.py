"""
    Alvin

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.1.0
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from alvin_api_client.api_client import ApiClient, Endpoint as _Endpoint
from alvin_api_client.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from alvin_api_client.model.admin_config import AdminConfig
from alvin_api_client.model.alvin_description_request import AlvinDescriptionRequest
from alvin_api_client.model.auth_provider import AuthProvider
from alvin_api_client.model.client_config import ClientConfig
from alvin_api_client.model.connection_direction import ConnectionDirection
from alvin_api_client.model.connection_type import ConnectionType
from alvin_api_client.model.connection_usage_classification import ConnectionUsageClassification
from alvin_api_client.model.data_entity_get import DataEntityGet
from alvin_api_client.model.data_entity_lineage_v2_request import DataEntityLineageV2Request
from alvin_api_client.model.data_entity_lineage_v2_response import DataEntityLineageV2Response
from alvin_api_client.model.data_entity_numerical_stat_response import DataEntityNumericalStatResponse
from alvin_api_client.model.data_entity_type import DataEntityType
from alvin_api_client.model.data_entity_usage_stats_report import DataEntityUsageStatsReport
from alvin_api_client.model.data_entity_usage_stats_request import DataEntityUsageStatsRequest
from alvin_api_client.model.data_platform_big_query_create import DataPlatformBigQueryCreate
from alvin_api_client.model.data_platform_full import DataPlatformFull
from alvin_api_client.model.data_platform_get import DataPlatformGet
from alvin_api_client.model.data_platform_job_step import DataPlatformJobStep
from alvin_api_client.model.data_platform_job_step_aggregated_report import DataPlatformJobStepAggregatedReport
from alvin_api_client.model.data_platform_job_step_report_type import DataPlatformJobStepReportType
from alvin_api_client.model.data_platform_job_step_request import DataPlatformJobStepRequest
from alvin_api_client.model.data_platform_job_step_user import DataPlatformJobStepUser
from alvin_api_client.model.data_platform_looker_create import DataPlatformLookerCreate
from alvin_api_client.model.data_platform_mode_create import DataPlatformModeCreate
from alvin_api_client.model.data_platform_redshift_create import DataPlatformRedshiftCreate
from alvin_api_client.model.data_platform_snowflake_create import DataPlatformSnowflakeCreate
from alvin_api_client.model.data_platform_tableau_create import DataPlatformTableauCreate
from alvin_api_client.model.data_platform_type import DataPlatformType
from alvin_api_client.model.data_taxonomy_classification import DataTaxonomyClassification
from alvin_api_client.model.email_login_request import EmailLoginRequest
from alvin_api_client.model.exchange_token_request import ExchangeTokenRequest
from alvin_api_client.model.experience import Experience
from alvin_api_client.model.experience_data import ExperienceData
from alvin_api_client.model.filters_response import FiltersResponse
from alvin_api_client.model.http_validation_error import HTTPValidationError
from alvin_api_client.model.impact_analysis_query_validation import ImpactAnalysisQueryValidation
from alvin_api_client.model.impact_analysis_request import ImpactAnalysisRequest
from alvin_api_client.model.impact_analysis_v2_response import ImpactAnalysisV2Response
from alvin_api_client.model.impact_analysis_validation_payload import ImpactAnalysisValidationPayload
from alvin_api_client.model.job_integration_request import JobIntegrationRequest
from alvin_api_client.model.job_query_v1_response import JobQueryV1Response
from alvin_api_client.model.limit_offset_page_api_keys_response import LimitOffsetPageAPIKeysResponse
from alvin_api_client.model.limit_offset_page_data_entity_get import LimitOffsetPageDataEntityGet
from alvin_api_client.model.limit_offset_page_data_entity_numerical_stat import LimitOffsetPageDataEntityNumericalStat
from alvin_api_client.model.limit_offset_page_data_entity_usage_stat_raw import LimitOffsetPageDataEntityUsageStatRaw
from alvin_api_client.model.limit_offset_page_data_entity_usage_stats_report import LimitOffsetPageDataEntityUsageStatsReport
from alvin_api_client.model.limit_offset_page_data_platform_job import LimitOffsetPageDataPlatformJob
from alvin_api_client.model.limit_offset_page_data_platform_job_entity_aggregated_report import LimitOffsetPageDataPlatformJobEntityAggregatedReport
from alvin_api_client.model.limit_offset_page_tag_entity_get import LimitOffsetPageTagEntityGet
from alvin_api_client.model.notification import Notification
from alvin_api_client.model.tag_entity_request import TagEntityRequest
from alvin_api_client.model.tag_values import TagValues
from alvin_api_client.model.tiny_url_response import TinyURLResponse
from alvin_api_client.model.token import Token
from alvin_api_client.model.user_get import UserGet
from alvin_api_client.model.user_organization_api_key_request import UserOrganizationAPIKeyRequest
from alvin_api_client.model.user_organization_api_key_response import UserOrganizationAPIKeyResponse


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.airflow_bigquery_save_lineage_api_v1_integrations_airflow_bigquery_post_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [],
                'endpoint_path': '/api/v1/integrations/airflow/bigquery',
                'operation_id': 'airflow_bigquery_save_lineage_api_v1_integrations_airflow_bigquery_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'job_integration_request',
                ],
                'required': [
                    'job_integration_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'job_integration_request':
                        (JobIntegrationRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'job_integration_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_api_key_api_v1_api_key_post_endpoint = _Endpoint(
            settings={
                'response_type': (UserOrganizationAPIKeyResponse,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/api-key',
                'operation_id': 'create_api_key_api_v1_api_key_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_organization_api_key_request',
                ],
                'required': [
                    'user_organization_api_key_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_organization_api_key_request':
                        (UserOrganizationAPIKeyRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'user_organization_api_key_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_bigquery_platform_api_v1_platforms_bigquery_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/bigquery',
                'operation_id': 'create_bigquery_platform_api_v1_platforms_bigquery_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_big_query_create',
                ],
                'required': [
                    'data_platform_big_query_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_big_query_create':
                        (DataPlatformBigQueryCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_big_query_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_looker_platform_api_v1_platforms_looker_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/looker',
                'operation_id': 'create_looker_platform_api_v1_platforms_looker_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_looker_create',
                ],
                'required': [
                    'data_platform_looker_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_looker_create':
                        (DataPlatformLookerCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_looker_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_mode_platform_api_v1_platforms_mode_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/mode',
                'operation_id': 'create_mode_platform_api_v1_platforms_mode_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_mode_create',
                ],
                'required': [
                    'data_platform_mode_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_mode_create':
                        (DataPlatformModeCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_mode_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_redshift_platform_api_v1_platforms_redshift_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/redshift',
                'operation_id': 'create_redshift_platform_api_v1_platforms_redshift_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_redshift_create',
                ],
                'required': [
                    'data_platform_redshift_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_redshift_create':
                        (DataPlatformRedshiftCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_redshift_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_snowflake_platform_api_v1_platforms_snowflake_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/snowflake',
                'operation_id': 'create_snowflake_platform_api_v1_platforms_snowflake_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_snowflake_create',
                ],
                'required': [
                    'data_platform_snowflake_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_snowflake_create':
                        (DataPlatformSnowflakeCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_snowflake_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_tableau_platform_api_v1_platforms_tableau_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/tableau',
                'operation_id': 'create_tableau_platform_api_v1_platforms_tableau_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_tableau_create',
                ],
                'required': [
                    'data_platform_tableau_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_tableau_create':
                        (DataPlatformTableauCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_tableau_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_update_entity_description_api_v1_entity_alvin_description_post_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/alvin-description',
                'operation_id': 'create_update_entity_description_api_v1_entity_alvin_description_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'alvin_description_request',
                ],
                'required': [
                    'alvin_description_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'alvin_description_request':
                        (AlvinDescriptionRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'alvin_description_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_api_key_api_v1_api_keys_api_key_prefix_delete_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/api-keys/{api_key_prefix}',
                'operation_id': 'delete_api_key_api_v1_api_keys_api_key_prefix_delete',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'api_key_prefix',
                ],
                'required': [
                    'api_key_prefix',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'api_key_prefix':
                        (str,),
                },
                'attribute_map': {
                    'api_key_prefix': 'api_key_prefix',
                },
                'location_map': {
                    'api_key_prefix': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_platform_api_v1_platforms_platform_id_delete_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/{platform_id}',
                'operation_id': 'delete_platform_api_v1_platforms_platform_id_delete',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.email_login_api_v1_auth_email_login_post_endpoint = _Endpoint(
            settings={
                'response_type': (EmailLoginRequest,),
                'auth': [],
                'endpoint_path': '/api/v1/auth/email-login',
                'operation_id': 'email_login_api_v1_auth_email_login_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'email_login_request',
                ],
                'required': [
                    'email_login_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'email_login_request':
                        (EmailLoginRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'email_login_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.exchange_token_api_v1_auth_exchange_token_post_endpoint = _Endpoint(
            settings={
                'response_type': (Token,),
                'auth': [],
                'endpoint_path': '/api/v1/auth/exchange-token',
                'operation_id': 'exchange_token_api_v1_auth_exchange_token_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'provider_id',
                    'exchange_token_request',
                    'org_id',
                ],
                'required': [
                    'provider_id',
                    'exchange_token_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'provider_id':
                        (AuthProvider,),
                    'exchange_token_request':
                        (ExchangeTokenRequest,),
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'provider_id': 'provider_id',
                    'org_id': 'orgId',
                },
                'location_map': {
                    'provider_id': 'query',
                    'exchange_token_request': 'body',
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.find_entity_by_id_api_v1_entity_find_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/find',
                'operation_id': 'find_entity_by_id_api_v1_entity_find_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_admin_config_api_v1_admin_config_get_endpoint = _Endpoint(
            settings={
                'response_type': (AdminConfig,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/admin-config',
                'operation_id': 'get_admin_config_api_v1_admin_config_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_all_taxonomy_classifications_api_v1_taxonomy_all_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataTaxonomyClassification],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/taxonomy/all',
                'operation_id': 'get_all_taxonomy_classifications_api_v1_taxonomy_all_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_api_key_info_api_v1_api_keys_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageAPIKeysResponse,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/api-keys',
                'operation_id': 'get_api_key_info_api_v1_api_keys_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_bigquery_platform_api_v1_platforms_bigquery_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformBigQueryCreate,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/bigquery/{platform_id}',
                'operation_id': 'get_bigquery_platform_api_v1_platforms_bigquery_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_child_taxonomy_classification_api_v1_taxonomy_children_classification_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataTaxonomyClassification],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/taxonomy/children/{classification}',
                'operation_id': 'get_child_taxonomy_classification_api_v1_taxonomy_children_classification_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'classification',
                ],
                'required': [
                    'classification',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'classification':
                        (str,),
                },
                'attribute_map': {
                    'classification': 'classification',
                },
                'location_map': {
                    'classification': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_client_config_api_v1_client_config_get_endpoint = _Endpoint(
            settings={
                'response_type': (ClientConfig,),
                'auth': [],
                'endpoint_path': '/api/v1/client-config',
                'operation_id': 'get_client_config_api_v1_client_config_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'org_id',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'org_id':
                        (str,),
                },
                'attribute_map': {
                    'org_id': 'orgId',
                },
                'location_map': {
                    'org_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entities_usage_stats_post_api_v1_entities_usage_stats_post_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityUsageStatsReport,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entities/usage-stats',
                'operation_id': 'get_entities_usage_stats_post_api_v1_entities_usage_stats_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'data_entity_usage_stats_request',
                    'limit',
                    'offset',
                    'sort',
                ],
                'required': [
                    'platform_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'data_entity_usage_stats_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'sort',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                    ('sort',): {

                        'regex': {
                            'pattern': r'^[\w: ]*$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        ([str],),
                    'entity_type':
                        ([str],),
                    'start_timestamp':
                        (datetime,),
                    'end_timestamp':
                        (datetime,),
                    'data_entity_usage_stats_request':
                        (DataEntityUsageStatsRequest,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        ([str],),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_type': 'entityType',
                    'start_timestamp': 'startTimestamp',
                    'end_timestamp': 'endTimestamp',
                    'limit': 'limit',
                    'offset': 'offset',
                    'sort': 'sort',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_type': 'query',
                    'start_timestamp': 'query',
                    'end_timestamp': 'query',
                    'data_entity_usage_stats_request': 'body',
                    'limit': 'query',
                    'offset': 'query',
                    'sort': 'query',
                },
                'collection_format_map': {
                    'platform_id': 'multi',
                    'entity_type': 'multi',
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_entity_api_v1_entity_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity',
                'operation_id': 'get_entity_api_v1_entity_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_children_api_v1_entity_children_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity-children',
                'operation_id': 'get_entity_children_api_v1_entity_children_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'has_connections',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'has_connections',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'has_connections':
                        (bool,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'has_connections': 'hasConnections',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'has_connections': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_children_api_v1_most_recent_entity_numerical_stats_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityNumericalStat,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/most-recent-entity-numerical-stats',
                'operation_id': 'get_entity_children_api_v1_most_recent_entity_numerical_stats_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_data_taxonomy_api_v1_entity_taxonomy_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataTaxonomyClassification],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/taxonomy',
                'operation_id': 'get_entity_data_taxonomy_api_v1_entity_taxonomy_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_jobs_api_v1_entity_jobs_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataPlatformJob,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity-jobs',
                'operation_id': 'get_entity_jobs_api_v1_entity_jobs_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_lineage_api_v2_lineage_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataEntityLineageV2Response,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v2/lineage',
                'operation_id': 'get_entity_lineage_api_v2_lineage_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_entity_lineage_v2_request',
                ],
                'required': [
                    'data_entity_lineage_v2_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_entity_lineage_v2_request':
                        (DataEntityLineageV2Request,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_entity_lineage_v2_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_entity_numerical_stats_api_v1_get_entity_numerical_stats_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataEntityNumericalStatResponse,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/get-entity-numerical-stats',
                'operation_id': 'get_entity_numerical_stats_api_v1_get_entity_numerical_stats_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'start_timestamp':
                        (datetime,),
                    'end_timestamp':
                        (datetime,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'start_timestamp': 'startTimestamp',
                    'end_timestamp': 'endTimestamp',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'start_timestamp': 'query',
                    'end_timestamp': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_parents_api_v1_entity_parents_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataEntityGet],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity-parents',
                'operation_id': 'get_entity_parents_api_v1_entity_parents_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_schema_api_v1_entity_entity_schema_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/entity-schema',
                'operation_id': 'get_entity_schema_api_v1_entity_entity_schema_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'limit',
                    'offset',
                    'get_entity_classifications',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'get_entity_classifications':
                        (bool,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'limit': 'limit',
                    'offset': 'offset',
                    'get_entity_classifications': 'get_entity_classifications',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'limit': 'query',
                    'offset': 'query',
                    'get_entity_classifications': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_siblings_api_v1_entity_siblings_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity-siblings',
                'operation_id': 'get_entity_siblings_api_v1_entity_siblings_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_tags_api_v1_entity_tags_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageTagEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/tags',
                'operation_id': 'get_entity_tags_api_v1_entity_tags_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_usage_stats_api_v1_entity_usage_stats_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataEntityUsageStatsReport,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/usage-stats',
                'operation_id': 'get_entity_usage_stats_api_v1_entity_usage_stats_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'usage_type',
                    'user_name',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        ([str],),
                    'start_timestamp':
                        (datetime,),
                    'end_timestamp':
                        (datetime,),
                    'usage_type':
                        ([str],),
                    'user_name':
                        ([str],),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'start_timestamp': 'startTimestamp',
                    'end_timestamp': 'endTimestamp',
                    'usage_type': 'usageType',
                    'user_name': 'userName',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'start_timestamp': 'query',
                    'end_timestamp': 'query',
                    'usage_type': 'query',
                    'user_name': 'query',
                },
                'collection_format_map': {
                    'entity_type': 'multi',
                    'usage_type': 'multi',
                    'user_name': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_entity_usage_stats_raw_api_v1_entity_usage_stats_raw_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityUsageStatRaw,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/usage-stats-raw',
                'operation_id': 'get_entity_usage_stats_raw_api_v1_entity_usage_stats_raw_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'connection_type',
                    'connection_direction',
                    'connection_usage_classification',
                    'usage_type',
                    'user_name',
                    'sort',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_id',
                    'entity_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'sort',
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('sort',): {

                        'regex': {
                            'pattern': r'^[\w: ]*$',  # noqa: E501
                        },
                    },
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'entity_id':
                        (str,),
                    'entity_type':
                        (str,),
                    'start_timestamp':
                        (datetime,),
                    'end_timestamp':
                        (datetime,),
                    'connection_type':
                        (ConnectionType,),
                    'connection_direction':
                        (ConnectionDirection,),
                    'connection_usage_classification':
                        (ConnectionUsageClassification,),
                    'usage_type':
                        ([str],),
                    'user_name':
                        ([str],),
                    'sort':
                        ([str],),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_id': 'entityId',
                    'entity_type': 'entityType',
                    'start_timestamp': 'startTimestamp',
                    'end_timestamp': 'endTimestamp',
                    'connection_type': 'connectionType',
                    'connection_direction': 'connectionDirection',
                    'connection_usage_classification': 'connectionUsageClassification',
                    'usage_type': 'usageType',
                    'user_name': 'userName',
                    'sort': 'sort',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_id': 'query',
                    'entity_type': 'query',
                    'start_timestamp': 'query',
                    'end_timestamp': 'query',
                    'connection_type': 'query',
                    'connection_direction': 'query',
                    'connection_usage_classification': 'query',
                    'usage_type': 'query',
                    'user_name': 'query',
                    'sort': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                    'usage_type': 'multi',
                    'user_name': 'multi',
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_experiences_api_v1_experience_get_endpoint = _Endpoint(
            settings={
                'response_type': ([Experience],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/experience',
                'operation_id': 'get_experiences_api_v1_experience_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'lead_user_email',
                    'user_persona',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'lead_user_email':
                        (str,),
                    'user_persona':
                        (str,),
                },
                'attribute_map': {
                    'lead_user_email': 'lead_user_email',
                    'user_persona': 'user_persona',
                },
                'location_map': {
                    'lead_user_email': 'query',
                    'user_persona': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_filters_config_api_v1_filters_config_get_endpoint = _Endpoint(
            settings={
                'response_type': (FiltersResponse,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/filters/config',
                'operation_id': 'get_filters_config_api_v1_filters_config_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'filter_view',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'filter_view':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'filter_view': 'filterView',
                },
                'location_map': {
                    'filter_view': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_impact_by_query_api_v2_impact_analysis_query_post_endpoint = _Endpoint(
            settings={
                'response_type': (ImpactAnalysisV2Response,),
                'auth': [],
                'endpoint_path': '/api/v2/impact-analysis/query',
                'operation_id': 'get_impact_by_query_api_v2_impact_analysis_query_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'impact_analysis_request',
                ],
                'required': [
                    'impact_analysis_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'impact_analysis_request':
                        (ImpactAnalysisRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'impact_analysis_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_impact_from_validation_payload_api_v2_impact_analysis_query_entities_post_endpoint = _Endpoint(
            settings={
                'response_type': (ImpactAnalysisV2Response,),
                'auth': [],
                'endpoint_path': '/api/v2/impact-analysis/query-entities',
                'operation_id': 'get_impact_from_validation_payload_api_v2_impact_analysis_query_entities_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'impact_analysis_validation_payload',
                ],
                'required': [
                    'impact_analysis_validation_payload',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'impact_analysis_validation_payload':
                        (ImpactAnalysisValidationPayload,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'impact_analysis_validation_payload': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_job_steps_aggregated_stats_api_v1_job_steps_aggregated_stats_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformJobStepAggregatedReport,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/job/steps/aggregated-stats',
                'operation_id': 'get_job_steps_aggregated_stats_api_v1_job_steps_aggregated_stats_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'job_hash',
                    'platform_id',
                    'report_type',
                    'local_timezone',
                ],
                'required': [
                    'job_hash',
                    'platform_id',
                    'report_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'job_hash':
                        (str,),
                    'platform_id':
                        (str,),
                    'report_type':
                        (DataPlatformJobStepReportType,),
                    'local_timezone':
                        (str,),
                },
                'attribute_map': {
                    'job_hash': 'jobHash',
                    'platform_id': 'platformId',
                    'report_type': 'reportType',
                    'local_timezone': 'localTimezone',
                },
                'location_map': {
                    'job_hash': 'query',
                    'platform_id': 'query',
                    'report_type': 'query',
                    'local_timezone': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_job_steps_api_v1_jobs_steps_post_endpoint = _Endpoint(
            settings={
                'response_type': ([DataPlatformJobStep],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/jobs/steps',
                'operation_id': 'get_job_steps_api_v1_jobs_steps_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_job_step_request',
                    'metadata_fields',
                ],
                'required': [
                    'data_platform_job_step_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_job_step_request':
                        (DataPlatformJobStepRequest,),
                    'metadata_fields':
                        (str,),
                },
                'attribute_map': {
                    'metadata_fields': 'metadataFields',
                },
                'location_map': {
                    'data_platform_job_step_request': 'body',
                    'metadata_fields': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_jobs_steps_aggregated_stats_api_v1_jobs_steps_aggregated_stats_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataPlatformJobEntityAggregatedReport,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/jobs/steps/aggregated-stats',
                'operation_id': 'get_jobs_steps_aggregated_stats_api_v1_jobs_steps_aggregated_stats_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'entity_id',
                    'platform_id',
                    'platform_type',
                    'entity_type',
                    'report_type',
                    'level',
                    'limit',
                    'offset',
                    'local_timezone',
                    'upstream',
                ],
                'required': [
                    'entity_id',
                    'platform_id',
                    'platform_type',
                    'entity_type',
                    'report_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'entity_id':
                        (str,),
                    'platform_id':
                        (str,),
                    'platform_type':
                        (str,),
                    'entity_type':
                        (DataEntityType,),
                    'report_type':
                        (DataPlatformJobStepReportType,),
                    'level':
                        (int,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'local_timezone':
                        (str,),
                    'upstream':
                        (bool,),
                },
                'attribute_map': {
                    'entity_id': 'entityId',
                    'platform_id': 'platformId',
                    'platform_type': 'platformType',
                    'entity_type': 'entityType',
                    'report_type': 'reportType',
                    'level': 'level',
                    'limit': 'limit',
                    'offset': 'offset',
                    'local_timezone': 'localTimezone',
                    'upstream': 'upstream',
                },
                'location_map': {
                    'entity_id': 'query',
                    'platform_id': 'query',
                    'platform_type': 'query',
                    'entity_type': 'query',
                    'report_type': 'query',
                    'level': 'query',
                    'limit': 'query',
                    'offset': 'query',
                    'local_timezone': 'query',
                    'upstream': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_jobs_users_api_v1_jobs_users_post_endpoint = _Endpoint(
            settings={
                'response_type': ([DataPlatformJobStepUser],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/jobs/users',
                'operation_id': 'get_jobs_users_api_v1_jobs_users_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'data_entity_usage_stats_request',
                    'limit',
                    'offset',
                ],
                'required': [
                    'platform_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'data_entity_usage_stats_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        ([str],),
                    'entity_type':
                        ([str],),
                    'start_timestamp':
                        (datetime,),
                    'end_timestamp':
                        (datetime,),
                    'data_entity_usage_stats_request':
                        (DataEntityUsageStatsRequest,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_type': 'entityType',
                    'start_timestamp': 'startTimestamp',
                    'end_timestamp': 'endTimestamp',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_type': 'query',
                    'start_timestamp': 'query',
                    'end_timestamp': 'query',
                    'data_entity_usage_stats_request': 'body',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                    'platform_id': 'multi',
                    'entity_type': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_last_job_query_api_v1_job_query_get_endpoint = _Endpoint(
            settings={
                'response_type': (JobQueryV1Response,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/job/query',
                'operation_id': 'get_last_job_query_api_v1_job_query_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'job_hash',
                    'platform_id',
                    'platform_type',
                ],
                'required': [
                    'job_hash',
                    'platform_id',
                    'platform_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'job_hash':
                        (str,),
                    'platform_id':
                        (str,),
                    'platform_type':
                        (DataPlatformType,),
                },
                'attribute_map': {
                    'job_hash': 'jobHash',
                    'platform_id': 'platformId',
                    'platform_type': 'platformType',
                },
                'location_map': {
                    'job_hash': 'query',
                    'platform_id': 'query',
                    'platform_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_lineage_job_steps_api_v1_lineage_jobs_steps_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataPlatformJobStep],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/lineage/jobs/steps',
                'operation_id': 'get_lineage_job_steps_api_v1_lineage_jobs_steps_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'from_entity_id',
                    'from_entity_type',
                    'from_entity_platform_id',
                    'to_entity_id',
                    'to_entity_type',
                    'to_entity_platform_id',
                ],
                'required': [
                    'from_entity_id',
                    'from_entity_type',
                    'from_entity_platform_id',
                    'to_entity_id',
                    'to_entity_type',
                    'to_entity_platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'from_entity_id':
                        (str,),
                    'from_entity_type':
                        (str,),
                    'from_entity_platform_id':
                        (str,),
                    'to_entity_id':
                        (str,),
                    'to_entity_type':
                        (str,),
                    'to_entity_platform_id':
                        (str,),
                },
                'attribute_map': {
                    'from_entity_id': 'fromEntityId',
                    'from_entity_type': 'fromEntityType',
                    'from_entity_platform_id': 'fromEntityPlatformId',
                    'to_entity_id': 'toEntityId',
                    'to_entity_type': 'toEntityType',
                    'to_entity_platform_id': 'toEntityPlatformId',
                },
                'location_map': {
                    'from_entity_id': 'query',
                    'from_entity_type': 'query',
                    'from_entity_platform_id': 'query',
                    'to_entity_id': 'query',
                    'to_entity_type': 'query',
                    'to_entity_platform_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_looker_platform_api_v1_platforms_looker_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformLookerCreate,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/looker/{platform_id}',
                'operation_id': 'get_looker_platform_api_v1_platforms_looker_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_mode_platform_api_v1_platforms_mode_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformModeCreate,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/mode/{platform_id}',
                'operation_id': 'get_mode_platform_api_v1_platforms_mode_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_notifications_api_v1_notifications_get_endpoint = _Endpoint(
            settings={
                'response_type': ([Notification],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/notifications',
                'operation_id': 'get_notifications_api_v1_notifications_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_org_tags_api_v1_org_tags_get_endpoint = _Endpoint(
            settings={
                'response_type': ([TagValues],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/org/tags',
                'operation_id': 'get_org_tags_api_v1_org_tags_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_parent_taxonomy_classifications_api_v1_taxonomy_parents_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataTaxonomyClassification],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/taxonomy/parents',
                'operation_id': 'get_parent_taxonomy_classifications_api_v1_taxonomy_parents_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_platform_api_v1_platforms_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/{platform_id}',
                'operation_id': 'get_platform_api_v1_platforms_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_platforms_api_v1_platforms_get_endpoint = _Endpoint(
            settings={
                'response_type': ([DataPlatformGet],),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms',
                'operation_id': 'get_platforms_api_v1_platforms_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_redshift_platform_api_v1_platforms_redshift_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformRedshiftCreate,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/redshift/{platform_id}',
                'operation_id': 'get_redshift_platform_api_v1_platforms_redshift_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_snowflake_platform_api_v1_platforms_snowflake_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformSnowflakeCreate,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/snowflake/{platform_id}',
                'operation_id': 'get_snowflake_platform_api_v1_platforms_snowflake_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_tableau_platform_api_v1_platforms_tableau_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformTableauCreate,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/tableau/{platform_id}',
                'operation_id': 'get_tableau_platform_api_v1_platforms_tableau_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_top_level_entities_api_v1_top_entities_get_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/top-entities',
                'operation_id': 'get_top_level_entities_api_v1_top_entities_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'limit',
                    'offset',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'limit': 'limit',
                    'offset': 'offset',
                },
                'location_map': {
                    'platform_id': 'query',
                    'limit': 'query',
                    'offset': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_top_level_entities_by_platform_api_v1_top_entities_platform_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/top-entities/{platformId}',
                'operation_id': 'get_top_level_entities_by_platform_api_v1_top_entities_platform_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_user_id_api_v1_user_id_get_endpoint = _Endpoint(
            settings={
                'response_type': (str,),
                'auth': [],
                'endpoint_path': '/api/v1/user/id',
                'operation_id': 'get_user_id_api_v1_user_id_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_email',
                ],
                'required': [
                    'user_email',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_email':
                        (str,),
                },
                'attribute_map': {
                    'user_email': 'userEmail',
                },
                'location_map': {
                    'user_email': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_user_info_api_v1_me_get_endpoint = _Endpoint(
            settings={
                'response_type': (UserGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/me',
                'operation_id': 'get_user_info_api_v1_me_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_users_by_id_api_v1_users_get_endpoint = _Endpoint(
            settings={
                'response_type': ({str: (UserGet,)},),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/users',
                'operation_id': 'get_users_by_id_api_v1_users_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_ids',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_ids':
                        ([str],),
                },
                'attribute_map': {
                    'user_ids': 'userIds',
                },
                'location_map': {
                    'user_ids': 'query',
                },
                'collection_format_map': {
                    'user_ids': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_users_in_org_api_v1_org_users_get_endpoint = _Endpoint(
            settings={
                'response_type': ({str: (UserGet,)},),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/org-users',
                'operation_id': 'get_users_in_org_api_v1_org_users_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.register_interest_api_v1_experiences_register_interest_post_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/experiences/register-interest',
                'operation_id': 'register_interest_api_v1_experiences_register_interest_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'experience_data',
                ],
                'required': [
                    'experience_data',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'experience_data':
                        (ExperienceData,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'experience_data': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.request_access_api_v1_experiences_request_access_post_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/experiences/request-access',
                'operation_id': 'request_access_api_v1_experiences_request_access_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'experience_data',
                ],
                'required': [
                    'experience_data',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'experience_data':
                        (ExperienceData,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'experience_data': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.save_tag_entity_api_v1_entity_tags_post_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/entity/tags',
                'operation_id': 'save_tag_entity_api_v1_entity_tags_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'tag_entity_request',
                ],
                'required': [
                    'tag_entity_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'tag_entity_request':
                        (TagEntityRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'tag_entity_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.search_entities_stats_post_api_v1_search_entities_usage_stats_post_endpoint = _Endpoint(
            settings={
                'response_type': (LimitOffsetPageDataEntityUsageStatsReport,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/search/entities/usage-stats',
                'operation_id': 'search_entities_stats_post_api_v1_search_entities_usage_stats_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'data_entity_usage_stats_request',
                    'limit',
                    'offset',
                    'sort',
                ],
                'required': [
                    'platform_id',
                    'entity_type',
                    'start_timestamp',
                    'end_timestamp',
                    'data_entity_usage_stats_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                    'sort',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                        'inclusive_minimum': 1,
                    },
                    ('sort',): {

                        'regex': {
                            'pattern': r'^[\w: ]*$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        ([str],),
                    'entity_type':
                        ([str],),
                    'start_timestamp':
                        (datetime,),
                    'end_timestamp':
                        (datetime,),
                    'data_entity_usage_stats_request':
                        (DataEntityUsageStatsRequest,),
                    'limit':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        ([str],),
                },
                'attribute_map': {
                    'platform_id': 'platformId',
                    'entity_type': 'entityType',
                    'start_timestamp': 'startTimestamp',
                    'end_timestamp': 'endTimestamp',
                    'limit': 'limit',
                    'offset': 'offset',
                    'sort': 'sort',
                },
                'location_map': {
                    'platform_id': 'query',
                    'entity_type': 'query',
                    'start_timestamp': 'query',
                    'end_timestamp': 'query',
                    'data_entity_usage_stats_request': 'body',
                    'limit': 'query',
                    'offset': 'query',
                    'sort': 'query',
                },
                'collection_format_map': {
                    'platform_id': 'multi',
                    'entity_type': 'multi',
                    'sort': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.sync_platform_rpc_api_v1_platforms_platform_id_rpc_sync_get_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformGet,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/{platform_id}/rpc-sync',
                'operation_id': 'sync_platform_rpc_api_v1_platforms_platform_id_rpc_sync_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'platform_id',
                ],
                'required': [
                    'platform_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'platform_id':
                        (str,),
                },
                'attribute_map': {
                    'platform_id': 'platform_id',
                },
                'location_map': {
                    'platform_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.sync_sheet_api_v1_sync_sheet_get_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/sync-sheet',
                'operation_id': 'sync_sheet_api_v1_sync_sheet_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.test_bigquery_platform_api_v1_platforms_bigquery_test_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformFull,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/bigquery-test',
                'operation_id': 'test_bigquery_platform_api_v1_platforms_bigquery_test_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_big_query_create',
                ],
                'required': [
                    'data_platform_big_query_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_big_query_create':
                        (DataPlatformBigQueryCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_big_query_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.test_looker_platform_api_v1_platforms_looker_test_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformFull,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/looker-test',
                'operation_id': 'test_looker_platform_api_v1_platforms_looker_test_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_looker_create',
                ],
                'required': [
                    'data_platform_looker_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_looker_create':
                        (DataPlatformLookerCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_looker_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.test_mode_platform_api_v1_platforms_mode_test_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformFull,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/mode-test',
                'operation_id': 'test_mode_platform_api_v1_platforms_mode_test_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_mode_create',
                ],
                'required': [
                    'data_platform_mode_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_mode_create':
                        (DataPlatformModeCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_mode_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.test_redshift_platform_api_v1_platforms_redshift_test_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformFull,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/redshift-test',
                'operation_id': 'test_redshift_platform_api_v1_platforms_redshift_test_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_redshift_create',
                ],
                'required': [
                    'data_platform_redshift_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_redshift_create':
                        (DataPlatformRedshiftCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_redshift_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.test_snowflake_platform_api_v1_platforms_snowflake_test_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformFull,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/snowflake-test',
                'operation_id': 'test_snowflake_platform_api_v1_platforms_snowflake_test_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_snowflake_create',
                ],
                'required': [
                    'data_platform_snowflake_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_snowflake_create':
                        (DataPlatformSnowflakeCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_snowflake_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.test_tableau_platform_api_v1_platforms_tableau_test_post_endpoint = _Endpoint(
            settings={
                'response_type': (DataPlatformFull,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/platforms/tableau-test',
                'operation_id': 'test_tableau_platform_api_v1_platforms_tableau_test_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'data_platform_tableau_create',
                ],
                'required': [
                    'data_platform_tableau_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'data_platform_tableau_create':
                        (DataPlatformTableauCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'data_platform_tableau_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.tinyurl_api_v1_tinyurl_get_endpoint = _Endpoint(
            settings={
                'response_type': (TinyURLResponse,),
                'auth': [
                    'HTTPBearer'
                ],
                'endpoint_path': '/api/v1/tinyurl',
                'operation_id': 'tinyurl_api_v1_tinyurl_get',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'code',
                ],
                'required': [
                    'code',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'code':
                        (str,),
                },
                'attribute_map': {
                    'code': 'code',
                },
                'location_map': {
                    'code': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.validate_impact_analysis_query_api_v2_impact_analysis_validate_query_post_endpoint = _Endpoint(
            settings={
                'response_type': (ImpactAnalysisQueryValidation,),
                'auth': [],
                'endpoint_path': '/api/v2/impact-analysis/validate-query',
                'operation_id': 'validate_impact_analysis_query_api_v2_impact_analysis_validate_query_post',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'impact_analysis_request',
                ],
                'required': [
                    'impact_analysis_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'impact_analysis_request':
                        (ImpactAnalysisRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'impact_analysis_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def airflow_bigquery_save_lineage_api_v1_integrations_airflow_bigquery_post(
        self,
        job_integration_request,
        **kwargs
    ):
        """Airflow Bigquery Save Lineage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.airflow_bigquery_save_lineage_api_v1_integrations_airflow_bigquery_post(job_integration_request, async_req=True)
        >>> result = thread.get()

        Args:
            job_integration_request (JobIntegrationRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['job_integration_request'] = \
            job_integration_request
        return self.airflow_bigquery_save_lineage_api_v1_integrations_airflow_bigquery_post_endpoint.call_with_http_info(**kwargs)

    def create_api_key_api_v1_api_key_post(
        self,
        user_organization_api_key_request,
        **kwargs
    ):
        """Create Api Key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_api_key_api_v1_api_key_post(user_organization_api_key_request, async_req=True)
        >>> result = thread.get()

        Args:
            user_organization_api_key_request (UserOrganizationAPIKeyRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UserOrganizationAPIKeyResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_organization_api_key_request'] = \
            user_organization_api_key_request
        return self.create_api_key_api_v1_api_key_post_endpoint.call_with_http_info(**kwargs)

    def create_bigquery_platform_api_v1_platforms_bigquery_post(
        self,
        data_platform_big_query_create,
        **kwargs
    ):
        """Create Bigquery Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_bigquery_platform_api_v1_platforms_bigquery_post(data_platform_big_query_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_big_query_create (DataPlatformBigQueryCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_big_query_create'] = \
            data_platform_big_query_create
        return self.create_bigquery_platform_api_v1_platforms_bigquery_post_endpoint.call_with_http_info(**kwargs)

    def create_looker_platform_api_v1_platforms_looker_post(
        self,
        data_platform_looker_create,
        **kwargs
    ):
        """Create Looker Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_looker_platform_api_v1_platforms_looker_post(data_platform_looker_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_looker_create (DataPlatformLookerCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_looker_create'] = \
            data_platform_looker_create
        return self.create_looker_platform_api_v1_platforms_looker_post_endpoint.call_with_http_info(**kwargs)

    def create_mode_platform_api_v1_platforms_mode_post(
        self,
        data_platform_mode_create,
        **kwargs
    ):
        """Create Mode Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_mode_platform_api_v1_platforms_mode_post(data_platform_mode_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_mode_create (DataPlatformModeCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_mode_create'] = \
            data_platform_mode_create
        return self.create_mode_platform_api_v1_platforms_mode_post_endpoint.call_with_http_info(**kwargs)

    def create_redshift_platform_api_v1_platforms_redshift_post(
        self,
        data_platform_redshift_create,
        **kwargs
    ):
        """Create Redshift Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_redshift_platform_api_v1_platforms_redshift_post(data_platform_redshift_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_redshift_create (DataPlatformRedshiftCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_redshift_create'] = \
            data_platform_redshift_create
        return self.create_redshift_platform_api_v1_platforms_redshift_post_endpoint.call_with_http_info(**kwargs)

    def create_snowflake_platform_api_v1_platforms_snowflake_post(
        self,
        data_platform_snowflake_create,
        **kwargs
    ):
        """Create Snowflake Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_snowflake_platform_api_v1_platforms_snowflake_post(data_platform_snowflake_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_snowflake_create (DataPlatformSnowflakeCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_snowflake_create'] = \
            data_platform_snowflake_create
        return self.create_snowflake_platform_api_v1_platforms_snowflake_post_endpoint.call_with_http_info(**kwargs)

    def create_tableau_platform_api_v1_platforms_tableau_post(
        self,
        data_platform_tableau_create,
        **kwargs
    ):
        """Create Tableau Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_tableau_platform_api_v1_platforms_tableau_post(data_platform_tableau_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_tableau_create (DataPlatformTableauCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_tableau_create'] = \
            data_platform_tableau_create
        return self.create_tableau_platform_api_v1_platforms_tableau_post_endpoint.call_with_http_info(**kwargs)

    def create_update_entity_description_api_v1_entity_alvin_description_post(
        self,
        alvin_description_request,
        **kwargs
    ):
        """Create Update Entity Description  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_update_entity_description_api_v1_entity_alvin_description_post(alvin_description_request, async_req=True)
        >>> result = thread.get()

        Args:
            alvin_description_request (AlvinDescriptionRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['alvin_description_request'] = \
            alvin_description_request
        return self.create_update_entity_description_api_v1_entity_alvin_description_post_endpoint.call_with_http_info(**kwargs)

    def delete_api_key_api_v1_api_keys_api_key_prefix_delete(
        self,
        api_key_prefix,
        **kwargs
    ):
        """Delete Api Key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_api_key_api_v1_api_keys_api_key_prefix_delete(api_key_prefix, async_req=True)
        >>> result = thread.get()

        Args:
            api_key_prefix (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['api_key_prefix'] = \
            api_key_prefix
        return self.delete_api_key_api_v1_api_keys_api_key_prefix_delete_endpoint.call_with_http_info(**kwargs)

    def delete_platform_api_v1_platforms_platform_id_delete(
        self,
        platform_id,
        **kwargs
    ):
        """Delete Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_platform_api_v1_platforms_platform_id_delete(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.delete_platform_api_v1_platforms_platform_id_delete_endpoint.call_with_http_info(**kwargs)

    def email_login_api_v1_auth_email_login_post(
        self,
        email_login_request,
        **kwargs
    ):
        """Email Login  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.email_login_api_v1_auth_email_login_post(email_login_request, async_req=True)
        >>> result = thread.get()

        Args:
            email_login_request (EmailLoginRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            EmailLoginRequest
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['email_login_request'] = \
            email_login_request
        return self.email_login_api_v1_auth_email_login_post_endpoint.call_with_http_info(**kwargs)

    def exchange_token_api_v1_auth_exchange_token_post(
        self,
        provider_id,
        exchange_token_request,
        **kwargs
    ):
        """Exchange Token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.exchange_token_api_v1_auth_exchange_token_post(provider_id, exchange_token_request, async_req=True)
        >>> result = thread.get()

        Args:
            provider_id (AuthProvider):
            exchange_token_request (ExchangeTokenRequest):

        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Token
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['provider_id'] = \
            provider_id
        kwargs['exchange_token_request'] = \
            exchange_token_request
        return self.exchange_token_api_v1_auth_exchange_token_post_endpoint.call_with_http_info(**kwargs)

    def find_entity_by_id_api_v1_entity_find_get(
        self,
        platform_id,
        entity_id,
        **kwargs
    ):
        """Find Entity By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_entity_by_id_api_v1_entity_find_get(platform_id, entity_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        return self.find_entity_by_id_api_v1_entity_find_get_endpoint.call_with_http_info(**kwargs)

    def get_admin_config_api_v1_admin_config_get(
        self,
        **kwargs
    ):
        """Get Admin Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_admin_config_api_v1_admin_config_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            AdminConfig
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_admin_config_api_v1_admin_config_get_endpoint.call_with_http_info(**kwargs)

    def get_all_taxonomy_classifications_api_v1_taxonomy_all_get(
        self,
        **kwargs
    ):
        """Get All Taxonomy Classifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_taxonomy_classifications_api_v1_taxonomy_all_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataTaxonomyClassification]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_all_taxonomy_classifications_api_v1_taxonomy_all_get_endpoint.call_with_http_info(**kwargs)

    def get_api_key_info_api_v1_api_keys_get(
        self,
        **kwargs
    ):
        """Get Api Key Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_api_key_info_api_v1_api_keys_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageAPIKeysResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_api_key_info_api_v1_api_keys_get_endpoint.call_with_http_info(**kwargs)

    def get_bigquery_platform_api_v1_platforms_bigquery_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Bigquery Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_bigquery_platform_api_v1_platforms_bigquery_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformBigQueryCreate
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_bigquery_platform_api_v1_platforms_bigquery_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_child_taxonomy_classification_api_v1_taxonomy_children_classification_get(
        self,
        classification,
        **kwargs
    ):
        """Get Child Taxonomy Classification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_child_taxonomy_classification_api_v1_taxonomy_children_classification_get(classification, async_req=True)
        >>> result = thread.get()

        Args:
            classification (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataTaxonomyClassification]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['classification'] = \
            classification
        return self.get_child_taxonomy_classification_api_v1_taxonomy_children_classification_get_endpoint.call_with_http_info(**kwargs)

    def get_client_config_api_v1_client_config_get(
        self,
        **kwargs
    ):
        """Get Client Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_client_config_api_v1_client_config_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            org_id (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ClientConfig
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_client_config_api_v1_client_config_get_endpoint.call_with_http_info(**kwargs)

    def get_entities_usage_stats_post_api_v1_entities_usage_stats_post(
        self,
        platform_id,
        entity_type,
        start_timestamp,
        end_timestamp,
        data_entity_usage_stats_request,
        **kwargs
    ):
        """Get Entities Usage Stats Post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entities_usage_stats_post_api_v1_entities_usage_stats_post(platform_id, entity_type, start_timestamp, end_timestamp, data_entity_usage_stats_request, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id ([str]):
            entity_type ([str]):
            start_timestamp (datetime):
            end_timestamp (datetime):
            data_entity_usage_stats_request (DataEntityUsageStatsRequest):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            sort ([str]): [optional] if omitted the server will use the default value of ["usageCount:asc"]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityUsageStatsReport
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_type'] = \
            entity_type
        kwargs['start_timestamp'] = \
            start_timestamp
        kwargs['end_timestamp'] = \
            end_timestamp
        kwargs['data_entity_usage_stats_request'] = \
            data_entity_usage_stats_request
        return self.get_entities_usage_stats_post_api_v1_entities_usage_stats_post_endpoint.call_with_http_info(**kwargs)

    def get_entity_api_v1_entity_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_api_v1_entity_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_api_v1_entity_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_children_api_v1_entity_children_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        has_connections,
        **kwargs
    ):
        """Get Entity Children  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_children_api_v1_entity_children_get(platform_id, entity_id, entity_type, has_connections, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):
            has_connections (bool):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        kwargs['has_connections'] = \
            has_connections
        return self.get_entity_children_api_v1_entity_children_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_children_api_v1_most_recent_entity_numerical_stats_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Children  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_children_api_v1_most_recent_entity_numerical_stats_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityNumericalStat
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_children_api_v1_most_recent_entity_numerical_stats_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_data_taxonomy_api_v1_entity_taxonomy_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Data Taxonomy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_data_taxonomy_api_v1_entity_taxonomy_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataTaxonomyClassification]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_data_taxonomy_api_v1_entity_taxonomy_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_jobs_api_v1_entity_jobs_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_jobs_api_v1_entity_jobs_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataPlatformJob
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_jobs_api_v1_entity_jobs_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_lineage_api_v2_lineage_post(
        self,
        data_entity_lineage_v2_request,
        **kwargs
    ):
        """Get Entity Lineage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_lineage_api_v2_lineage_post(data_entity_lineage_v2_request, async_req=True)
        >>> result = thread.get()

        Args:
            data_entity_lineage_v2_request (DataEntityLineageV2Request):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataEntityLineageV2Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_entity_lineage_v2_request'] = \
            data_entity_lineage_v2_request
        return self.get_entity_lineage_api_v2_lineage_post_endpoint.call_with_http_info(**kwargs)

    def get_entity_numerical_stats_api_v1_get_entity_numerical_stats_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        start_timestamp,
        end_timestamp,
        **kwargs
    ):
        """Get Entity Numerical Stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_numerical_stats_api_v1_get_entity_numerical_stats_get(platform_id, entity_id, entity_type, start_timestamp, end_timestamp, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):
            start_timestamp (datetime):
            end_timestamp (datetime):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataEntityNumericalStatResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        kwargs['start_timestamp'] = \
            start_timestamp
        kwargs['end_timestamp'] = \
            end_timestamp
        return self.get_entity_numerical_stats_api_v1_get_entity_numerical_stats_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_parents_api_v1_entity_parents_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Parents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_parents_api_v1_entity_parents_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataEntityGet]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_parents_api_v1_entity_parents_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_schema_api_v1_entity_entity_schema_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_schema_api_v1_entity_entity_schema_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            get_entity_classifications (bool): [optional] if omitted the server will use the default value of True
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_schema_api_v1_entity_entity_schema_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_siblings_api_v1_entity_siblings_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Siblings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_siblings_api_v1_entity_siblings_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_siblings_api_v1_entity_siblings_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_tags_api_v1_entity_tags_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_tags_api_v1_entity_tags_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (DataEntityType):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageTagEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_tags_api_v1_entity_tags_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_usage_stats_api_v1_entity_usage_stats_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        start_timestamp,
        end_timestamp,
        **kwargs
    ):
        """Get Entity Usage Stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_usage_stats_api_v1_entity_usage_stats_get(platform_id, entity_id, entity_type, start_timestamp, end_timestamp, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type ([str]):
            start_timestamp (datetime):
            end_timestamp (datetime):

        Keyword Args:
            usage_type ([str]): [optional]
            user_name ([str]): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataEntityUsageStatsReport
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        kwargs['start_timestamp'] = \
            start_timestamp
        kwargs['end_timestamp'] = \
            end_timestamp
        return self.get_entity_usage_stats_api_v1_entity_usage_stats_get_endpoint.call_with_http_info(**kwargs)

    def get_entity_usage_stats_raw_api_v1_entity_usage_stats_raw_get(
        self,
        platform_id,
        entity_id,
        entity_type,
        **kwargs
    ):
        """Get Entity Usage Stats Raw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_entity_usage_stats_raw_api_v1_entity_usage_stats_raw_get(platform_id, entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):
            entity_id (str):
            entity_type (str):

        Keyword Args:
            start_timestamp (datetime): [optional]
            end_timestamp (datetime): [optional]
            connection_type (ConnectionType): [optional]
            connection_direction (ConnectionDirection): [optional]
            connection_usage_classification (ConnectionUsageClassification): [optional]
            usage_type ([str]): [optional]
            user_name ([str]): [optional]
            sort ([str]): [optional] if omitted the server will use the default value of ["start:desc"]
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityUsageStatRaw
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_id'] = \
            entity_id
        kwargs['entity_type'] = \
            entity_type
        return self.get_entity_usage_stats_raw_api_v1_entity_usage_stats_raw_get_endpoint.call_with_http_info(**kwargs)

    def get_experiences_api_v1_experience_get(
        self,
        **kwargs
    ):
        """Get Experiences  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_experiences_api_v1_experience_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            lead_user_email (str): [optional]
            user_persona (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [Experience]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_experiences_api_v1_experience_get_endpoint.call_with_http_info(**kwargs)

    def get_filters_config_api_v1_filters_config_get(
        self,
        **kwargs
    ):
        """Get Filters Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_filters_config_api_v1_filters_config_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            filter_view (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            FiltersResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_filters_config_api_v1_filters_config_get_endpoint.call_with_http_info(**kwargs)

    def get_impact_by_query_api_v2_impact_analysis_query_post(
        self,
        impact_analysis_request,
        **kwargs
    ):
        """Get Impact By Query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_impact_by_query_api_v2_impact_analysis_query_post(impact_analysis_request, async_req=True)
        >>> result = thread.get()

        Args:
            impact_analysis_request (ImpactAnalysisRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ImpactAnalysisV2Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['impact_analysis_request'] = \
            impact_analysis_request
        return self.get_impact_by_query_api_v2_impact_analysis_query_post_endpoint.call_with_http_info(**kwargs)

    def get_impact_from_validation_payload_api_v2_impact_analysis_query_entities_post(
        self,
        impact_analysis_validation_payload,
        **kwargs
    ):
        """Get Impact From Validation Payload  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_impact_from_validation_payload_api_v2_impact_analysis_query_entities_post(impact_analysis_validation_payload, async_req=True)
        >>> result = thread.get()

        Args:
            impact_analysis_validation_payload (ImpactAnalysisValidationPayload):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ImpactAnalysisV2Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['impact_analysis_validation_payload'] = \
            impact_analysis_validation_payload
        return self.get_impact_from_validation_payload_api_v2_impact_analysis_query_entities_post_endpoint.call_with_http_info(**kwargs)

    def get_job_steps_aggregated_stats_api_v1_job_steps_aggregated_stats_get(
        self,
        job_hash,
        platform_id,
        report_type,
        **kwargs
    ):
        """Get Job Steps Aggregated Stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_steps_aggregated_stats_api_v1_job_steps_aggregated_stats_get(job_hash, platform_id, report_type, async_req=True)
        >>> result = thread.get()

        Args:
            job_hash (str):
            platform_id (str):
            report_type (DataPlatformJobStepReportType):

        Keyword Args:
            local_timezone (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformJobStepAggregatedReport
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['job_hash'] = \
            job_hash
        kwargs['platform_id'] = \
            platform_id
        kwargs['report_type'] = \
            report_type
        return self.get_job_steps_aggregated_stats_api_v1_job_steps_aggregated_stats_get_endpoint.call_with_http_info(**kwargs)

    def get_job_steps_api_v1_jobs_steps_post(
        self,
        data_platform_job_step_request,
        **kwargs
    ):
        """Get Job Steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_job_steps_api_v1_jobs_steps_post(data_platform_job_step_request, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_job_step_request (DataPlatformJobStepRequest):

        Keyword Args:
            metadata_fields (str): [optional] if omitted the server will use the default value of "source_text,fingerprint,job_step_metadata"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataPlatformJobStep]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_job_step_request'] = \
            data_platform_job_step_request
        return self.get_job_steps_api_v1_jobs_steps_post_endpoint.call_with_http_info(**kwargs)

    def get_jobs_steps_aggregated_stats_api_v1_jobs_steps_aggregated_stats_get(
        self,
        entity_id,
        platform_id,
        platform_type,
        entity_type,
        report_type,
        **kwargs
    ):
        """Get Jobs Steps Aggregated Stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_steps_aggregated_stats_api_v1_jobs_steps_aggregated_stats_get(entity_id, platform_id, platform_type, entity_type, report_type, async_req=True)
        >>> result = thread.get()

        Args:
            entity_id (str):
            platform_id (str):
            platform_type (str):
            entity_type (DataEntityType):
            report_type (DataPlatformJobStepReportType):

        Keyword Args:
            level (int): [optional] if omitted the server will use the default value of 1
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            local_timezone (str): [optional]
            upstream (bool): [optional] if omitted the server will use the default value of True
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataPlatformJobEntityAggregatedReport
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['entity_id'] = \
            entity_id
        kwargs['platform_id'] = \
            platform_id
        kwargs['platform_type'] = \
            platform_type
        kwargs['entity_type'] = \
            entity_type
        kwargs['report_type'] = \
            report_type
        return self.get_jobs_steps_aggregated_stats_api_v1_jobs_steps_aggregated_stats_get_endpoint.call_with_http_info(**kwargs)

    def get_jobs_users_api_v1_jobs_users_post(
        self,
        platform_id,
        entity_type,
        start_timestamp,
        end_timestamp,
        data_entity_usage_stats_request,
        **kwargs
    ):
        """Get Jobs Users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_jobs_users_api_v1_jobs_users_post(platform_id, entity_type, start_timestamp, end_timestamp, data_entity_usage_stats_request, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id ([str]):
            entity_type ([str]):
            start_timestamp (datetime):
            end_timestamp (datetime):
            data_entity_usage_stats_request (DataEntityUsageStatsRequest):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 1000
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataPlatformJobStepUser]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_type'] = \
            entity_type
        kwargs['start_timestamp'] = \
            start_timestamp
        kwargs['end_timestamp'] = \
            end_timestamp
        kwargs['data_entity_usage_stats_request'] = \
            data_entity_usage_stats_request
        return self.get_jobs_users_api_v1_jobs_users_post_endpoint.call_with_http_info(**kwargs)

    def get_last_job_query_api_v1_job_query_get(
        self,
        job_hash,
        platform_id,
        platform_type,
        **kwargs
    ):
        """Get Last Job Query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_last_job_query_api_v1_job_query_get(job_hash, platform_id, platform_type, async_req=True)
        >>> result = thread.get()

        Args:
            job_hash (str):
            platform_id (str):
            platform_type (DataPlatformType):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            JobQueryV1Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['job_hash'] = \
            job_hash
        kwargs['platform_id'] = \
            platform_id
        kwargs['platform_type'] = \
            platform_type
        return self.get_last_job_query_api_v1_job_query_get_endpoint.call_with_http_info(**kwargs)

    def get_lineage_job_steps_api_v1_lineage_jobs_steps_get(
        self,
        from_entity_id,
        from_entity_type,
        from_entity_platform_id,
        to_entity_id,
        to_entity_type,
        to_entity_platform_id,
        **kwargs
    ):
        """Get Lineage Job Steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_lineage_job_steps_api_v1_lineage_jobs_steps_get(from_entity_id, from_entity_type, from_entity_platform_id, to_entity_id, to_entity_type, to_entity_platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            from_entity_id (str):
            from_entity_type (str):
            from_entity_platform_id (str):
            to_entity_id (str):
            to_entity_type (str):
            to_entity_platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataPlatformJobStep]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['from_entity_id'] = \
            from_entity_id
        kwargs['from_entity_type'] = \
            from_entity_type
        kwargs['from_entity_platform_id'] = \
            from_entity_platform_id
        kwargs['to_entity_id'] = \
            to_entity_id
        kwargs['to_entity_type'] = \
            to_entity_type
        kwargs['to_entity_platform_id'] = \
            to_entity_platform_id
        return self.get_lineage_job_steps_api_v1_lineage_jobs_steps_get_endpoint.call_with_http_info(**kwargs)

    def get_looker_platform_api_v1_platforms_looker_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Looker Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_looker_platform_api_v1_platforms_looker_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformLookerCreate
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_looker_platform_api_v1_platforms_looker_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_mode_platform_api_v1_platforms_mode_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Mode Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_mode_platform_api_v1_platforms_mode_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformModeCreate
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_mode_platform_api_v1_platforms_mode_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_notifications_api_v1_notifications_get(
        self,
        **kwargs
    ):
        """Get Notifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_notifications_api_v1_notifications_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [Notification]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_notifications_api_v1_notifications_get_endpoint.call_with_http_info(**kwargs)

    def get_org_tags_api_v1_org_tags_get(
        self,
        **kwargs
    ):
        """Get Org Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_org_tags_api_v1_org_tags_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [TagValues]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_org_tags_api_v1_org_tags_get_endpoint.call_with_http_info(**kwargs)

    def get_parent_taxonomy_classifications_api_v1_taxonomy_parents_get(
        self,
        **kwargs
    ):
        """Get Parent Taxonomy Classifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_parent_taxonomy_classifications_api_v1_taxonomy_parents_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataTaxonomyClassification]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_parent_taxonomy_classifications_api_v1_taxonomy_parents_get_endpoint.call_with_http_info(**kwargs)

    def get_platform_api_v1_platforms_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_platform_api_v1_platforms_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_platform_api_v1_platforms_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_platforms_api_v1_platforms_get(
        self,
        **kwargs
    ):
        """Get Platforms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_platforms_api_v1_platforms_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [DataPlatformGet]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_platforms_api_v1_platforms_get_endpoint.call_with_http_info(**kwargs)

    def get_redshift_platform_api_v1_platforms_redshift_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Redshift Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_redshift_platform_api_v1_platforms_redshift_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformRedshiftCreate
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_redshift_platform_api_v1_platforms_redshift_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_snowflake_platform_api_v1_platforms_snowflake_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Snowflake Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_snowflake_platform_api_v1_platforms_snowflake_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformSnowflakeCreate
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_snowflake_platform_api_v1_platforms_snowflake_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_tableau_platform_api_v1_platforms_tableau_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Tableau Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tableau_platform_api_v1_platforms_tableau_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformTableauCreate
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_tableau_platform_api_v1_platforms_tableau_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_top_level_entities_api_v1_top_entities_get(
        self,
        **kwargs
    ):
        """Get Top Level Entities  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_top_level_entities_api_v1_top_entities_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            platform_id (str): [optional]
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_top_level_entities_api_v1_top_entities_get_endpoint.call_with_http_info(**kwargs)

    def get_top_level_entities_by_platform_api_v1_top_entities_platform_id_get(
        self,
        platform_id,
        **kwargs
    ):
        """Get Top Level Entities By Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_top_level_entities_by_platform_api_v1_top_entities_platform_id_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.get_top_level_entities_by_platform_api_v1_top_entities_platform_id_get_endpoint.call_with_http_info(**kwargs)

    def get_user_id_api_v1_user_id_get(
        self,
        user_email,
        **kwargs
    ):
        """Get User Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_id_api_v1_user_id_get(user_email, async_req=True)
        >>> result = thread.get()

        Args:
            user_email (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            str
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_email'] = \
            user_email
        return self.get_user_id_api_v1_user_id_get_endpoint.call_with_http_info(**kwargs)

    def get_user_info_api_v1_me_get(
        self,
        **kwargs
    ):
        """Get User Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_info_api_v1_me_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UserGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_user_info_api_v1_me_get_endpoint.call_with_http_info(**kwargs)

    def get_users_by_id_api_v1_users_get(
        self,
        **kwargs
    ):
        """Get Users By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_users_by_id_api_v1_users_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            user_ids ([str]): [optional] if omitted the server will use the default value of []
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            {str: (UserGet,)}
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_users_by_id_api_v1_users_get_endpoint.call_with_http_info(**kwargs)

    def get_users_in_org_api_v1_org_users_get(
        self,
        **kwargs
    ):
        """Get Users In Org  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_users_in_org_api_v1_org_users_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            {str: (UserGet,)}
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.get_users_in_org_api_v1_org_users_get_endpoint.call_with_http_info(**kwargs)

    def register_interest_api_v1_experiences_register_interest_post(
        self,
        experience_data,
        **kwargs
    ):
        """Register Interest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_interest_api_v1_experiences_register_interest_post(experience_data, async_req=True)
        >>> result = thread.get()

        Args:
            experience_data (ExperienceData):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['experience_data'] = \
            experience_data
        return self.register_interest_api_v1_experiences_register_interest_post_endpoint.call_with_http_info(**kwargs)

    def request_access_api_v1_experiences_request_access_post(
        self,
        experience_data,
        **kwargs
    ):
        """Request Access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.request_access_api_v1_experiences_request_access_post(experience_data, async_req=True)
        >>> result = thread.get()

        Args:
            experience_data (ExperienceData):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['experience_data'] = \
            experience_data
        return self.request_access_api_v1_experiences_request_access_post_endpoint.call_with_http_info(**kwargs)

    def save_tag_entity_api_v1_entity_tags_post(
        self,
        tag_entity_request,
        **kwargs
    ):
        """Save Tag Entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.save_tag_entity_api_v1_entity_tags_post(tag_entity_request, async_req=True)
        >>> result = thread.get()

        Args:
            tag_entity_request (TagEntityRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['tag_entity_request'] = \
            tag_entity_request
        return self.save_tag_entity_api_v1_entity_tags_post_endpoint.call_with_http_info(**kwargs)

    def search_entities_stats_post_api_v1_search_entities_usage_stats_post(
        self,
        platform_id,
        entity_type,
        start_timestamp,
        end_timestamp,
        data_entity_usage_stats_request,
        **kwargs
    ):
        """Search Entities Stats Post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_entities_stats_post_api_v1_search_entities_usage_stats_post(platform_id, entity_type, start_timestamp, end_timestamp, data_entity_usage_stats_request, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id ([str]):
            entity_type ([str]):
            start_timestamp (datetime):
            end_timestamp (datetime):
            data_entity_usage_stats_request (DataEntityUsageStatsRequest):

        Keyword Args:
            limit (int): [optional] if omitted the server will use the default value of 50
            offset (int): [optional] if omitted the server will use the default value of 0
            sort ([str]): [optional] if omitted the server will use the default value of ["usageCount:asc"]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            LimitOffsetPageDataEntityUsageStatsReport
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        kwargs['entity_type'] = \
            entity_type
        kwargs['start_timestamp'] = \
            start_timestamp
        kwargs['end_timestamp'] = \
            end_timestamp
        kwargs['data_entity_usage_stats_request'] = \
            data_entity_usage_stats_request
        return self.search_entities_stats_post_api_v1_search_entities_usage_stats_post_endpoint.call_with_http_info(**kwargs)

    def sync_platform_rpc_api_v1_platforms_platform_id_rpc_sync_get(
        self,
        platform_id,
        **kwargs
    ):
        """Sync Platform Rpc  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sync_platform_rpc_api_v1_platforms_platform_id_rpc_sync_get(platform_id, async_req=True)
        >>> result = thread.get()

        Args:
            platform_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['platform_id'] = \
            platform_id
        return self.sync_platform_rpc_api_v1_platforms_platform_id_rpc_sync_get_endpoint.call_with_http_info(**kwargs)

    def sync_sheet_api_v1_sync_sheet_get(
        self,
        **kwargs
    ):
        """Sync Sheet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sync_sheet_api_v1_sync_sheet_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        return self.sync_sheet_api_v1_sync_sheet_get_endpoint.call_with_http_info(**kwargs)

    def test_bigquery_platform_api_v1_platforms_bigquery_test_post(
        self,
        data_platform_big_query_create,
        **kwargs
    ):
        """Test Bigquery Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.test_bigquery_platform_api_v1_platforms_bigquery_test_post(data_platform_big_query_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_big_query_create (DataPlatformBigQueryCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformFull
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_big_query_create'] = \
            data_platform_big_query_create
        return self.test_bigquery_platform_api_v1_platforms_bigquery_test_post_endpoint.call_with_http_info(**kwargs)

    def test_looker_platform_api_v1_platforms_looker_test_post(
        self,
        data_platform_looker_create,
        **kwargs
    ):
        """Test Looker Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.test_looker_platform_api_v1_platforms_looker_test_post(data_platform_looker_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_looker_create (DataPlatformLookerCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformFull
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_looker_create'] = \
            data_platform_looker_create
        return self.test_looker_platform_api_v1_platforms_looker_test_post_endpoint.call_with_http_info(**kwargs)

    def test_mode_platform_api_v1_platforms_mode_test_post(
        self,
        data_platform_mode_create,
        **kwargs
    ):
        """Test Mode Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.test_mode_platform_api_v1_platforms_mode_test_post(data_platform_mode_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_mode_create (DataPlatformModeCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformFull
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_mode_create'] = \
            data_platform_mode_create
        return self.test_mode_platform_api_v1_platforms_mode_test_post_endpoint.call_with_http_info(**kwargs)

    def test_redshift_platform_api_v1_platforms_redshift_test_post(
        self,
        data_platform_redshift_create,
        **kwargs
    ):
        """Test Redshift Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.test_redshift_platform_api_v1_platforms_redshift_test_post(data_platform_redshift_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_redshift_create (DataPlatformRedshiftCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformFull
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_redshift_create'] = \
            data_platform_redshift_create
        return self.test_redshift_platform_api_v1_platforms_redshift_test_post_endpoint.call_with_http_info(**kwargs)

    def test_snowflake_platform_api_v1_platforms_snowflake_test_post(
        self,
        data_platform_snowflake_create,
        **kwargs
    ):
        """Test Snowflake Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.test_snowflake_platform_api_v1_platforms_snowflake_test_post(data_platform_snowflake_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_snowflake_create (DataPlatformSnowflakeCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformFull
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_snowflake_create'] = \
            data_platform_snowflake_create
        return self.test_snowflake_platform_api_v1_platforms_snowflake_test_post_endpoint.call_with_http_info(**kwargs)

    def test_tableau_platform_api_v1_platforms_tableau_test_post(
        self,
        data_platform_tableau_create,
        **kwargs
    ):
        """Test Tableau Platform  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.test_tableau_platform_api_v1_platforms_tableau_test_post(data_platform_tableau_create, async_req=True)
        >>> result = thread.get()

        Args:
            data_platform_tableau_create (DataPlatformTableauCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            DataPlatformFull
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['data_platform_tableau_create'] = \
            data_platform_tableau_create
        return self.test_tableau_platform_api_v1_platforms_tableau_test_post_endpoint.call_with_http_info(**kwargs)

    def tinyurl_api_v1_tinyurl_get(
        self,
        code,
        **kwargs
    ):
        """Tinyurl  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tinyurl_api_v1_tinyurl_get(code, async_req=True)
        >>> result = thread.get()

        Args:
            code (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            TinyURLResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['code'] = \
            code
        return self.tinyurl_api_v1_tinyurl_get_endpoint.call_with_http_info(**kwargs)

    def validate_impact_analysis_query_api_v2_impact_analysis_validate_query_post(
        self,
        impact_analysis_request,
        **kwargs
    ):
        """Validate Impact Analysis Query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_impact_analysis_query_api_v2_impact_analysis_validate_query_post(impact_analysis_request, async_req=True)
        >>> result = thread.get()

        Args:
            impact_analysis_request (ImpactAnalysisRequest):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ImpactAnalysisQueryValidation
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['impact_analysis_request'] = \
            impact_analysis_request
        return self.validate_impact_analysis_query_api_v2_impact_analysis_validate_query_post_endpoint.call_with_http_info(**kwargs)

